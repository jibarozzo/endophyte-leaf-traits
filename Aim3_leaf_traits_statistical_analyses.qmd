---
title: "Aim3_Leaf_traits_Statistical_Analyses"
author: "Bolívar Aponte Rolón"
date: "Last edited: `r format(Sys.time(), '%B %d, %Y')`"
date: last-modified
date-format: "[Last updated on] MMMM D, YYYY"
bibliography: git_ref.bib
csl: apa.csl
format: 
  html:
    toc: true
    toc-location: left
    toc-depth: 2
    number-sections: true
    number-depth: 1
    theme: lumen
    highlight-style: github
    code-overflow: wrap
    code-fold: false
    code-copy: true
    code-link: false
    code-tools: false
    code-block-border-left: "#0C3823"
    code-block-bg: "#eeeeee"
    fig-cap-location: margin
    linestretch: 1.25
    fontsize: "large"
    embed-resources: true
execute:
  echo: true
  keep-md: true
editor: 
  markdown: 
    wrap: 72
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(out.width ='70%', fig_align = 'center', echo = TRUE, collapse = TRUE)
```

This are the statistical analyses for Aim 3 Leaf Traits and Endophytes project with Sunshine Van Bael from Tulane University, and E.A. Arnold from the University of Arizona. The bioinformatic analyses and data files (e.g., .csv) produced are a product of files *Aim3_Sequence_Data_Cleaning.R* and *Aim_3_Prelim_analyses_9SEPT2020.Rmd*. The first file, cleans and shapes the OTU files produced from the bioinformatic analyses completed with VSEARCH. The taxonomic assignment was completed with T-BAS. The second file explores correlations and distributions of covariates for this project.

# R packages used

Not all of these packages are used. They are here just in case need further along the analyses.

```{r}
#| echo: false
#| warning: false
# Data manipulation and visualizations ####
library("rmarkdown")
library("conflicted")
library("devtools")
#library("DiagrammeR")
library("factoextra")
library("ggfortify")
library("ggiraph")
library("ggiraphExtra")
library("ggplot2")
library("ggpubr")
library("gridExtra")
library("ggthemes")
library("hrbrthemes")
library("igraph")
library("tidyverse")
library("plotrix")
#library("viridis")
library("MetBrewer")
library("formatR")
library("wesanderson")
#library("knitr")
library("data.table")
library("kableExtra")
library("janitor")
library("flextable")
library("vtable")

# Stats ####
library("broom")
library("vegan")
library("nlme")
library("MASS")
library("MuMIn")
library("car") #For type 3 Anova with Anova() function.
library("PerformanceAnalytics")
library("corrr")
library("permute")
library("lattice")
library("pls")
library("buildmer")
library("lme4")
library("sjPlot")
library("glmmTMB")
library("indicspecies")

# Phylogenetic analyses #source("https://raw.githubusercontent.com/joey711/phyloseq/master/inst/scripts/installer.R",local = TRUE)
library("mgcv")
library("phyloseq")
library("ape")
library("metagMisc")
#remotes::install_github("vmikk/metagMisc")
#library("speedyseq")
library("picante")
#source("http://bioconductor.org/biocLite.R")


# Preference of conflicted functions among packages ####
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer_all("phyloseq")
```

# Working Directory

```{r}
rm(list = ls()) 
#setwd("H:/.shortcut-targets-by-id/0B9v0CdUUCqU5VVR4a3BvNHM1Z28/VBL_users/Grad_Students/Bolivar/Dissertation/Leaf_Traits_Panama/Data/Sequence_analyses")

#Working Directory and Path for Windows
#setwd("C:/Users/boloq/Box/Dissertation/Leaf_Traits_Panama/Data/Aim3_Sequence_analyses")
#save.path <- "C:/Users/boloq/Box/Dissertation/Leaf_Traits_Panama/Data/Aim3_Sequence_analyses"

#Working Directory and Path for Linux
setwd("/home/baponte/Boxx/Dissertation/Leaf_Traits_Panama/Data/Aim3_Sequence_analyses/")
# 
save.path <- ("/home/baponte/Boxx/Dissertation/Leaf_Traits_Panama/Data/Aim3_Sequence_analyses/")
```

# Post VSEARCH and T-BAS sequence pre-processing

```{r, Post VSEARCH and T-BAS data cleaning}
#Script for cleaning and reshaping Sample and PCR blanks Sequence data for Leaf Traits Panama
#Bolívar Aponte Rolón
#February 16, 2022
#Last modified: November 30, 2023

####################################################
###Cleaning and reshaping Blanks and PCR_CONTROLS###
####################################################

# pcrdata <- read.csv("clean_data/post_biopipeline/All_PCR_R1_otuFINAL_95.csv") #PCR2NEGPLATE1 is missing. This is due to mislabeling in the original sequence files.
# #There is a q.fastq.gz file that might be this sample.INSPECT THIS FILE. G:\My Drive\VBL_users\Grad_Students\Bolivar\Dissertation\Leaf_Traits_Panama\Data\Sample_Sequencing\Post_Sequencing\Original_Sample_gzip_files
# #The issue stated in the above line has been resolved as of March 10, 2022. -BAR
# 
# pcrdata <- pcrdata |>
#   rename(OTU_ID = X.OTU.ID)
# 
# ###Cleaning and reshaping Samples###
# ####################################
# 
# realsamp <- read.csv("clean_data/post_biopipeline/All_Samples_R1_otuFINAL95.csv")
# 
# realsamp <- realsamp |>
#   na.omit() |>
#   rename(OTU_ID = X.OTU.ID)
# 
# ###############################################################################
# ###Full_join of the data frames to retain all values and row and transposing###
# ###############################################################################
# 
# #joined <- full_join(realsamp,pcrdata, by = "OTU_ID" ) |>
#  # mutate(across(everything(), replace_na, replace = 0))
# 
# joined <- full_join(realsamp,pcrdata, by = "OTU_ID" ) |>
#   dplyr::mutate(across(c(2:168),~replace_na(.x, 0)))
# str(joined)
# 
# joined.t <- as.data.frame(t(joined))
# str(joined.t)
# 
# names(joined.t) <- joined.t |> slice(1) |> unlist()
# 
# joined.t <-  joined.t |> 
#   rownames_to_column("Sample_names") |>
#   slice(-1)
#  
# str(joined.t)
# 
# #####################################################
# ###Make subset tables from each sequence plate run###
# #####################################################
# 
# ################### Plate1 #####################
# 
# filter_table1<- read.csv("filters/Filter_Table_Plate1.csv")
# 
# names(filter_table1)
# filter_table1 <- filter_table1 |>
#   rename(A = ?..A)
# str(filter_table1)
# 
# filter_table1 <-filter_table1 |> 
#   pivot_longer(cols = 1:12, names_to = "samples", values_to = "values") |>
#   select(-samples) |>
#   slice(-5, -6)
# 
# plate1 <- semi_join(joined.t, filter_table1, by= c("Sample_names" = "values"))
# 
# plate1 <- plate1 |>
#   mutate(across(!Sample_names, as.numeric))
# plate1 <- as_tibble(plate1)
# 
# filter_filter <- anti_join( filter_table1, plate1, by = c("values"="Sample_names"))#Corroborating if indeed all match. Supposed to be ZERO.
# str(plate1)
# 
# #From factor dataframe to numeric
# 
# indx <- sapply(plate1, is.tibble)
# plate1[indx] <- lapply(plate1[indx], function(x) as.numeric(as.character(x)))
# 
# ################ Plate2 ####################
# 
# filter_table2<- read.csv("filters/Filter_Table_Plate2.csv")
# 
# names(filter_table2)
# 
# filter_table2 <- filter_table2 |>
#   rename(A = ?..A)
# 
# filter_table2 <- filter_table2 |> 
#   pivot_longer(cols = 1:10, names_to = "samples", values_to = "values") |>
#   select(-samples) |>
#   slice(-69, -70, -71, -77, -78, -79, -80)
# 
# plate2 <- semi_join(joined.t, filter_table2, by= c("Sample_names" = "values"))
# 
# plate2 <- plate2 |>
#   mutate(across(!Sample_names, as.numeric))
# plate2 <- as_tibble(plate2)
# filter_filter <- anti_join( filter_table2, plate2, by = c("values"="Sample_names")) #Corroborating if indeed all match. 
# str(plate2)
# 
# #From factor dataframe to numeric
# 
# indx <- sapply(plate2, is.tibble)
# plate2[indx] <- lapply(plate2[indx], function(x) as.numeric(as.character(x)))
# 
# ###################################
# ###CC_fungi Contaminant removal.### 
# ###Adapted from MARIE and Shuzo Oita#####
# ###This code works by substracting the SUM of contaminants from each OTU cell. 
# ###If the value is negative it replaces it with 0. 
# 
# ########MARELI MAGIC#########
# ##### Substracts the sum of the average of the ExtractionBlank avg and PCR negative control of Batch 001 from OTU sample reads, then removed control rows #####
# ######################################
# 
# ################### Plate1 #####################
# 
# as.data.frame(plate1)
# plate1 <- column_to_rownames(plate1, var = "Sample_names")
# 
# #add column with sums for each OTU
# 
# cont <- row.names(plate1)
# cont <- cont[92:94] #change accordingly to your data - these are the negative controls
# contamination <- c()
# for(c in 1:ncol(plate1)){
#   contamination[c]<- mean(plate1[rownames(plate1) %in% cont, c], na.rm = TRUE)
# }
# plate1 <-rbind(plate1, contamination)
# row.names(plate1)[95] <- "contamination" #change the name of row 104
# 
# ###subtract total contaminants from each OTU, if it is a negative number make it 0
# cont2 <- c(cont, "contamination")
# row <- which(!rownames(plate1) %in% cont2)
# for(r in row){
#   for(c in 1:ncol(plate1)){
#     if(plate1[r,c] > plate1["contamination",c]) {
#       new_reads <- plate1[r,c] - plate1["contamination",c]
#       plate1[r,c] <- new_reads
#     } else {plate1[r,c] <- 0}
#   }
# }
# 
# 
# ##remove controls from dataframe and makes a text file to paste into existing excel sheet
# 
# new_data_decontaminated001 <- plate1[!rownames(plate1) %in% cont2, ]
# write.table(new_data_decontaminated001,"clean_data/otu_data/MinusNegsBlanks_001.txt", sep="\t") ### This became tab "Filtered-BlankNegbyCode" in "ExtractionBatch0001_PCR102NC.xlsx". 
# 
# 
# ################### Plate2 #####################
# 
# as.data.frame(plate2)
# plate2 <- column_to_rownames(plate2, var = "Sample_names")
# 
# #add column with sums for each OTU
# 
# cont <- row.names(plate2)
# cont <- cont[66:73] #change accordingly to your data - these are the negative controls
# contamination <- c()
# for(c in 1:ncol(plate2)){
#   contamination[c]<- mean(plate2[rownames(plate2) %in% cont, c], na.rm = TRUE)
# }
# plate2 <-rbind(plate2, contamination)
# row.names(plate2)[74] <- "contamination" #change the name of row 104
# 
# ###subtract total contaminants from each OTU, if it is a negative number make it 0
# 
# cont2 <- c(cont, "contamination")
# row <- which(!rownames(plate2) %in% cont2)
# for(r in row){
#   for(c in 1:ncol(plate2)){
#     if(plate2[r,c] > plate2["contamination",c]) {
#       new_reads <- plate2[r,c] - plate2["contamination",c]
#       plate2[r,c] <- new_reads
#     } else {plate2[r,c] <- 0}
#   }
# }
# 
# 
# 
# ##remove controls from dataframe and makes a text file to paste into exisitng excel sheet
# 
# new_data_decontaminated002 <- plate2[!rownames(plate2) %in% cont2, ]
# write.table(new_data_decontaminated002,"clean_data/otu_data/MinusNegsBlanks_002.txt", sep="\t")
# 
# 
# ###################################
# ####Saving decontaminated file ####
# ###################################
# all_complete_decontaminated <- bind_rows(new_data_decontaminated001, new_data_decontaminated002)
# 
# write.csv(all_complete_decontaminated,"clean_data/otu_data/all_Decontaminated_byBlankandNegs_complete.csv")
# trans <- t(all_complete_decontaminated)
# trans <- as.data.frame(trans)
# write.csv(trans, "clean_data/otu_data/all_toFilt_10_percent.csv") ## in the format to remove <10% OTUs -- see below
# 
# 
# 
# ##########################################################################
# #### Script to remove < 0.10% abundance per sample #### From Shuzo Oita###
# ##########################################################################
# ## csv file should have row = OTU, col = sample
# 
# otu.data <- read.csv('clean_data/otu_data/all_toFilt_10_percent.csv', row.names = 1,as.is = T)
# otu.data <- apply(otu.data, 2, function(x) ifelse({100*x/sum(x)} < 0.10, 0, x))
# OTU_table.cleaned <- subset((otu.data2), rowSums(otu.data2)>1)
# OTU_table.cleaned <- as.data.frame(OTU_table.cleaned)
# write.csv(OTU_table.cleaned, "all_cleaned_at_10_percent.csv")
```

# Data frames

Data frames needed for diversity, abundance, and richness analyses using clean sample sequences data (no contaminants). T-BAS taxonomic assignment and leaf traits data set.

### Clean sample sequences

```{r, Clean sequences}
set.seed(123)
# Cleaned (decontaminated) sample sequences ####
#csamp
# csamp <- read.csv("clean_data/otu_data/all_cleaned_at_10_percent.csv")
# csamp[,2:157] <- lapply(csamp[,2:157], as.integer)
# csamp <- csamp |>
#   rename(OTU_ID = X) |>
#   column_to_rownames(var = "OTU_ID") |>
#   na.omit() |>
#   na.fail() |>
#   as.matrix()

# Saving
# saveRDS(csamp, file.path(save.path, "R_objects/clean_sequences.rds"))

# Reading
csamp <- readRDS(file.path(save.path, "R_objects/clean_sequences.rds"))
```

### T-BAS

```{r, TBAS}
# T-BAS taxonomic assignment ####
#tbas
# tbas <- read.csv("unite_report2BSDHQZP.csv")
# tbas <- tbas |>
#   dplyr::filter(phylum == "Ascomycota") |>
#   select(-match,-e.value, -percent, -coverage, -bitscore) |> #eliminating some columns that I am not really using
#   na.omit()|>
#   rename( OTU_ID = query) |>
#   column_to_rownames(var = "OTU_ID") |>
#   na.omit() |>
#   na.fail() |>
#   as.matrix()

# Saving
#saveRDS(tbas, file.path(save.path, "R_objects/tbas_filtered.rds"))

# Reading
tbas <- readRDS(file.path(save.path, "R_objects/tbas_filtered.rds"))
```

### Leaf traits measurements

```{r, Leaf trait variables data}
# data

data <- read.csv("field_data/Aim3_Bolivar_Summer_2019_Leaf_Traits_datasheet.csv")

# data
# Data set created on May 23, 2023 for analysis with raw data.
data <- data |>
  separate(Unique_ID, c("Trial_Code", "ELoad", "Species2", "Replicate")) |>
  unite("Sample_name", Species2:Replicate, sep = "") |>
  relocate(Sample_name, Trial_Code, E_load, .after = Species) |>
  select(!c(5, 15:17, 20)) |>
  rename( Anthocyanins = Anthocyanins..aci.,
          Thickness = Thickness..micro.m.,
          Toughness =Toughness..lbf.,
          LMA = LMA_dw,
          Abun_3 = Abundance_Proportion_day3,
          Abun_7 = Abundance_Proportion_day7)

# Saving
# saveRDS(data, file.path(save.path, "R_objects/leaf_data_raw_analyses.rds"))

# Reading
data <- readRDS(file.path(save.path, "R_objects/leaf_data_raw_analyses.rds"))

# ndata (new_data)
# This data set can also be used to conduct analyses summarized by leaf.

# ndata <- data |>
#   group_by(Sample_name, Species, Trial_Code, Trial_type, E_load, Leaf_ID) |>
#   summarise(Anthocyanins = mean(Anthocyanins, na.rm = TRUE),
#             Thickness = mean(Thickness, na.rm = TRUE),
#             Toughness = mean(Toughness, na.rm = TRUE),
#             LMA = mean(LMA, na.rm = TRUE),
#             Abun_3 = mean(Abun_3, na.rm = TRUE),
#             Abun_7 = mean(Abun_7, na.rm = TRUE)) |>
#   ungroup() |>
#    mutate_if(is.character, as.factor) |>
#   na.omit() |>
#   na.fail()

# Saving
# saveRDS(ndata, file.path(save.path, "R_objects/new_leaf_data.rds"))

# Reading
ndata <- readRDS(file.path(save.path, "R_objects/new_leaf_data.rds"))

# Splitting and relocating Unique_ID column 
# Extract names to match to phyloseq objects separate(Species2, c("Species3", "Numbers"), sep = "(?<=[A-Za-z])(?=[0-9])")

# ndata2 (new_data2)
# Data frame is summarized by plant (n = 156)

# ndata2 <- ndata |> 
#   select(!c(Abun_3, Abun_7)) |>
#   mutate_if(is.character, as.factor) |>
#   group_by(Sample_name, Species, Trial_type, Trial_Code, E_load) |>
#   summarise(Anthocyanins = mean(Anthocyanins, na.rm = TRUE),
#             Thickness = mean(Thickness, na.rm = TRUE),
#             Toughness = mean(Toughness, na.rm =TRUE),
#             LMA = mean(LMA, na.rm = TRUE)) 

# Saving
# saveRDS(ndata2, file.path(save.path, "R_objects/new_leaf_data2.rds"))

# Reading
ndata2 <- readRDS(file.path(save.path, "R_objects/new_leaf_data2.rds"))

# Glimpse
glimpse(data)
glimpse(csamp)
glimpse(tbas)
glimpse(ndata)
glimpse(ndata2)

```

### Ant and Pathogen assay data

For this data set I have calculated the area or percent area loss of leaf by the ants. I need to calculate the rate of loss. **How fast did the ants cut off leaf matter?** This data set also need cleaning and calculation of other variables. **How fast did the pathogen spread?**

The code below cleans the `ants` data set by removing all the variables with incomplete data or not important for our current analyses. Additionally it eliminates unsuccessful trials (labeled by 0 in Trial_success) as well a trial \# 10 which is missing data for one of the treatments. It is important to remove the trial as a whole to be able to performed paired t-tests.

```{r, Ant assay data}

#ants <- read.csv("field_data/Aim3_Bolivar_Summer_2019_Ant_Assay_datasheet.csv")
# 
# ants <- ants |>
#   separate(Unique.ID, c("Trial_Code", "ELoad", "Species2", "Replicate")) |>
#   unite("Sample_name", Species2:Replicate, sep = "") |>
#   relocate(Species, Trial_Code,.after = Sample_name)|>
#   slice(-c(11,12)) |>
#   dplyr::filter(Trial_success!="0") |>
#   select(!c(Leaf_ID, 
#             Colony_ID, 
#             Picture_ID, 
#             Colony_location_Pipeline.Gamboa, 
#             Attempt, 
#             Date_analyzed, 
#             X_coordinates, 
#             Y_coordinates, 
#             Elevation_meters, 
#             ELoad, 
#             Analyzer, 
#             Time_start_trial, 
#             Time_first_contact, 
#             Time_first_cut, 
#             Time_end_elapsed_trial )) |>
#   mutate(Ant_percent_leafloss = -100*{(Leaf_area_final-Leaf_area_initial)/Leaf_area_initial}) |>
#   mutate_if(is.character, as.factor)

# Saving
# saveRDS(ants, file.path(save.path, "R_objects/ants_data.rds"))

# Reading
ants <- readRDS(file.path(save.path, "R_objects/ants_data.rds"))


# Just the area loss
ants2 <- ants |>
  select(c(1,3,4,9,10))

# ants3 <- ants |>
#   select(c(1,3,4,5,9,10))


# Glimpse
 glimpse(ants)
 glimpse(ants2)
```

I removed rows for trials T1-T2 of THEO samples and T5 of APEIME samples (rows 41:48, 97:100, respectively). Removing these Trials because they have missing data and they are paired. Only removing the row with missing data would create an uneven paired data set. Making paired t-tests troublesome.

```{r, Pathogen Assay Data}

# patho <- read.csv("field_data/Aim3_Bolivar_Summer_2019_Patho_Assay_datasheet.csv")
# 
# patho <- patho |>
#   separate(Unique.ID, c("Trial_Code", "ELoad", "Species2", "Replicate")) |>
#   unite("Sample_name", Species2:Replicate, sep = "") |>
#   relocate(Species, Trial_Code,.after = Sample_name) |>
#   slice(-c(41:48, 97:100)) |>
#   select(!c(ELoad,
#             Leaf_ID,
#             Trial_start_time,
#             Date, 
#             ImageJ_link, 
#             X, 
#             Notes)) |>
#   rename(Treatment = Treatment_Ctrl_Pathogen) |>
#   mutate(Pathogen_percent_damage = (Damage_area/Leaf_area)) |>
#   mutate_if(is.character, as.factor)

# Saving
# saveRDS(patho, file.path(save.path, "R_objects/pathogen_data.rds"))

# Reading
patho <- readRDS(file.path(save.path, "R_objects/pathogen_data.rds"))


#Just the area damaged
patho2 <- patho |>
  select(c(1,3,4,8,9,12))


patho3 <- patho |>
  select(c(1,3,4,6,7,8,9,12))

#Glimpse
glimpse(patho)
glimpse(patho2)
kable(head(patho2))
```

## Phyloseq objects and dataframes

The taxonomic assignment was completed with T-BAS. The file `unite_report2BSDHQZP.csv` returned is what I used for creating the `phyloseq` objects. Here I bind the taxonomy, OTUs and sample metadata together. All is done with the `phyloseq` package. For reference <https://joey711.github.io/phyloseq/>.

```{r, Objects and dataframes}
### Phyloseq objects ####

# OTU Table: 1774 OTU with 156 Samples
# OTU <- otu_table(csamp, taxa_are_rows = TRUE)
# OTU

# Saving
# saveRDS(OTU, file.path(save.path, "R_objects/otu_table.rds"))

# Taxonomic Table: 1473 OTU by 7 taxonomic ranks
# TAX <- tax_table(tbas)

# Saving
# saveRDS(TAX, file.path(save.path, "R_objects/taxonomy_table.rds"))

# SAMP (sample metadata)

# SAMP <- ndata2 |>
#   column_to_rownames(var = "Sample_name")
# SAMP <- sample_data(SAMP)

# Saving
# saveRDS(SAMP, file.path(save.path, "R_objects/samp_data.rds"))


# Merging phyloseq objects ####
# pq1 <- phyloseq(OTU, TAX, SAMP)

# Saving
# saveRDS(pq1, file.path(save.path, "R_objects/phyloseq_main.rds"))

# Reading
pq1 <- readRDS(file.path(save.path, "R_objects/phyloseq_main.rds"))

# Random tree ####
#random_tree <- rtree(ntaxa(pq), rooted=TRUE, tip.label=taxa_names(pq))

#write.nexus(random_tree, file = "random_tree.nex") #Creating nexus file to latter manipulate with FigTree software.
```

### Pre-processing: Ascomycota

**Code modified from Mareli Sánchez Juliá.**

Are there any taxa with no (0) reads? \#

```{r, Mareli code}
# pq2 <- prune_taxa(taxa_sums(pq1) > 0, pq1)
# ntaxa(pq2) #There are 488 taxa with 0 reads.

# Saving
# saveRDS(pq2, file.path(save.path, "R_objects/phyloseq_pq2.rds"))

# Reading
pq2 <- readRDS(file.path(save.path, "R_objects/phyloseq_pq2.rds"))

# Subset of pq1 -- only E+ samples and OTUs.
#Important -- don't remove OTUs with 0 reads here, because we want to know which ones have no reads in E+ but DO have reads in E-.
pq2E <- subset_samples(pq2, E_load == "E+")
ntaxa(pq2E) #1219 taxa and 78 samples

# Eliminate E- only OTUs. Keep OTUs with more than 0 reads in subset.
pq2_EminusRemoved <- prune_taxa(taxa_sums(pq2E) > 0, pq2E)
ntaxa(pq2_EminusRemoved) #959 taxa remain. 260 OTUs removed.

#If OTU has 0 reads in E+, it will have reads in E-, so this prunes pq2E and identifies all OTUs that have 0 reads in E+, which by default, are the OTUs that DO have reads in E-.
pq2_EminuOnly <- prune_taxa(taxa_sums(pq2E) == 0, pq2E)
pq2_EminuOnly #260 taxa and 78 samples

# Gets names of OTUs and make a data frame with column name the same as in pq2
EminusOTUs2 <- taxa_names(pq2_EminuOnly)
EminusOTUsList2 <- as.data.frame(EminusOTUs2)
#write.table(EminusOTUsList2, "clean_data/otu_data/Aim3_RemovedOTUsList.txt")

# Get vectors (names) of numbered OTUs from pq1
OTU_ID <- rownames(otu_table(pq1))

# Returns all OTU names that don't have a match in Eminus OTUs.
notShared <- setdiff(OTU_ID, EminusOTUs2)

# Subset phyloseq object to only these OTUs
pq2ET <- subset(otu_table(pq2), rownames(otu_table(pq2)) %in% notShared)

# Exported into "Sequence Analyses"
#write.csv(pq2ET, "clean_data/Aim3_OTU_phyloseq_trimmed.csv")

# New phyloseq object without E- OTUs.
newpq <- merge_phyloseq(pq2ET, tax_table(pq2), sample_data(pq2), rtree(ntaxa(pq2), rooted=TRUE, tip.label=taxa_names(pq2)))

# Relative Abundance of 959 OTUs. No removal of singletons yet.

# rawra <- transform_sample_counts(newpq, function(x)x/sum(x))
# rawRA <- subset(otu_table(rawra), rownames(otu_table(rawra)) %in% notShared)
# write.csv(rawRA, "clean_data/otu_data/Aim3_OTU_Relative_Abundance_singletons_untrimmed.csv")

# Outputs of this script -- OTU table without E minus only OTUs and phyloseq object with E- OTUs removed. No removal of singletons yet.

# End of Mareli's Code #
```

### Singleton removal

```{r, Singleton removal}
# Filtering Taxa: Removal of singletons ####
 # Removal of  singletons
newpq1 <- filter_taxa(newpq, function (x) {sum(x > 0) > 1}, prune=TRUE)
# The result is 2,464,558 sequence reads from 569 taxa in 156 samples.

# Relative abundance calculation ####
# Code below is for making the .csv file. After that refer to df rawra from .csv file.

# newpqRA <- transform_sample_counts(newpq1, function(x)x/sum(x))
# rabun <- subset(otu_table(newpqRA), rownames(otu_table(newpqRA)) %in% notShared)
# write.csv(rabun, "clean_data/otu_data/Aim3_OTU_Relative_Abundance_singletons_trimmed.csv")
#GPfr = filter_taxa(GPr, function(x) mean(x) > 1e-5, TRUE)


# Richness data frame ####
rich <- estimate_richness(newpq1, split = TRUE, measures = c("Observed","Shannon"))
rich
rich <- rich |>
  rownames_to_column() |>
  rename(Sample_name = rowname)

# Phyloseq object to data frames ####

# Cleaned: no singletons
newpqDF <- phyloseq_to_df(newpq1, addtax = T, addtot = F, addmaxrank = F, sorting = "abundance")
#write.csv(newpqDF, "clean_data/otu_data/Aim3_OTUs_assigned_nonsingletons.csv")

paged_table(head(newpqDF))
```

```{r, Loading phyloseq products}

#These are the data frames resulting from the phyloseq data wrangling.

#The 569 OTUs and 156 samples (total abundances)
newpqDF <- read.csv("clean_data/otu_data/Aim3_OTUs_assigned_nonsingletons.csv")
newpqDF <- newpqDF |>  # Code from the Taxonomical assginment section dopes the same. This is just calling it directly from the /csv to avoid running all the code. 
  select(!c(1))

# OTUs 959 and 156 samples (total abundances)

# eOTU <- read.csv("clean_data/Aim3_OTU_phyloseq_trimmed.csv") 
# Can upload as data frame. Use for distance matrices.
# 
# eOTU2 <- eOTU |>
#   rename(OTU_ID = X) |>
#   column_to_rownames(var = "OTU_ID") |>
#   t() |>
#   as.data.frame() |>
#   rownames_to_column() |>
#   rename(Sample_name = rowname)

# Saving
#saveRDS(eOTU2, file.path(save.path, "R_objects/eOTU2.rds"))

# Reading
eOTU2 <- readRDS(file.path(save.path, "R_objects/eOTU2.rds"))


# Just 569 OTUs and 156 samples (total abundances)
# cOTU <- newpqDF |>
#   select(-kingdom, -phylum, -class, -order, -family, -genus, -species) |>
#   column_to_rownames(var = "OTU") |>
#   as.matrix() |>
#   t() |>
#   as.data.frame() |>
#   rownames_to_column() |>
#   rename(Sample_name = rowname)

# Saving
# saveRDS(cOTU, file.path(save.path, "R_objects/clean_OTU.rds"))

# Reading
cOTU <- readRDS(file.path(save.path, "R_objects/clean_OTU.rds"))

# Relative Abundance matrix (trimmed to 569 OTUs)
# rabun <- read.csv("clean_data/otu_data/Aim3_OTU_Relative_Abundance_singletons_trimmed.csv")
# rabun <- rabun |>
#   rename(OTU_ID = X) |>
#   column_to_rownames(var = "OTU_ID") |>
#   na.omit() |>
#   na.fail() |>
#   as.matrix()

# Saving
# saveRDS(rabun, file.path(save.path, "R_objects/rabun_tidy.rds"))

# Reading
rabun <- readRDS(file.path(save.path, "R_objects/rabun_tidy.rds"))

# Relative Abundance matrix (singletons untrimmed Ascomycota 959 OTUs)
# rawra <- read.csv("clean_data/otu_data/Aim3_OTU_Relative_Abundance_singletons_untrimmed.csv")
# rawra <- rawra |>
#   rename(OTU_ID = X) |>
#   column_to_rownames(var = "OTU_ID") |>
#   na.omit() |>
#   na.fail() |>
#   as.matrix()

# Saving
# saveRDS(rawra, file.path(save.path, "R_objects/rawra_tidy.rds"))

# Reading
rawra <- readRDS(file.path(save.path, "R_objects/rawra_tidy.rds"))

```

# Master data set: richness, diversity and abundances post-phyloseq

This data frame combines all the necessary richness, diversty and relative abundance estimates post-`phyloseq` manipulation with the data frames from the ant and pathogen assays. This is useful for testing hypothesis directly from one data set.

```{r, Master data set}
#This contains all the OTU id's per sample type. Hence, 156 (# samples) observations per OTU_ID. The phyloseq object achieves the same purpose. This data set is easier to use with other functions or test not supported by phyloseq.

# Master ####
#put all data frames into list
df_list <- list(ndata2, cOTU, ants2, patho2, rich)    

#merge all data frames together
master <- df_list |> 
  reduce(left_join, by= "Sample_name", "E_load") |>
  mutate(Total_reads = sum(across(starts_with("OTU")))) |>
  group_by(Species) |>
  mutate(Relative_Abundance = Total_reads/sum(Total_reads)*100) |>
  select(c(1:9, 579:591)) |>
  select(!c(E_load,
            E_load.y,
            Trial_Code,
            Trial_Code.y)) |>
  relocate(Treatment, E_load.x, .after = Trial_type) |>
  rename(Pathogen_Damage_area = Damage_area, 
         E_load = E_load.x, 
         Trial_Code = Trial_Code.x)

  # master_NAs <- master |>
  # na.omit()

  
#Master with leaf traits
# put all data frames into list
# df_list <- list(ndata2, cOTU, ants3, patho3, rich)
# master2 <- df_list |>
#   reduce(left_join, by= "Sample_name", "E_load") |>
#  mutate(Total_reads = sum(across(starts_with("OTU")))) |>
#   group_by(Species) |>
#   mutate(Relative_Abundance = Total_reads/sum(Total_reads)) |>
#    select(!c(E_load,
#             E_load.y,
#             Trial_Code,
#             Trial_Code.y)) |>
#   relocate(c(579:590), .after = LMA)|>
#    rename(Pathogen_Damage_area = Damage_area,
#          E_load = E_load.x,
#          Trial_Code = Trial_Code.x)
# write.csv(master2, "clean_data/Aim3_master_data_11APR2023.csv")
# Glimpse
glimpse(master)
```

For `master` I remove empty rows just as I did in above section. Because I use `left_join()` with `ndata2` it returns empty cells for ant assay data but complete leaf trait measurements.

### `masterant` and `masterant2`

```{r, Ant Master Data}
# Masterant on a per plant level
masterant <- master |>
  subset(Trial_type == "Ant") |>
  drop_na(Trial_Code) |>
  select(!c(4, 13:14)) |>
  na.omit()

# Glimpse
glimpse(masterant)


# Masterant on a per leaf level (70 plants, 3 leaves per plant = 210 leaves measured)
df_list_ant2 <- list(ndata, cOTU, ants2, patho2, rich)

masterant2 <- df_list_ant2 |>
  reduce(left_join, by= "Sample_name", "E_load") |>
 mutate(Total_reads = sum(across(starts_with("OTU")))) |>
  group_by(Species) |>
  mutate(Relative_Abundance = Total_reads/sum(Total_reads)) |>
  select(c(1:10, 584:594)) |>
  select(!c(E_load,
            Trial_Code)) |>
  relocate(Treatment, E_load.x, .after = Trial_type) |>
  rename(Pathogen_Damage_area = Damage_area, 
         E_load = E_load.x, 
         Trial_Code = Trial_Code.x) |>
  subset(Trial_type == "Ant") |>
  drop_na(Trial_Code) |>
  select(!c(5, 14:15)) |>
  na.omit() |>
  mutate(logit_herbivory = logit(Ant_percent_leafloss))
# Glimpse
glimpse(masterant2)
```

For `masterant` I remove THEO T1 & T2 and APE28-29 just as I did in above section. I need to do this again because in creating the `master` data frame I join the data with `left_join()`. It results in rows with missing pathogen assay data and complete leaf trait data.

### `masterpat` and `masterpat2`

```{r, Pathogen Master data}
# Pathogen Observations per plant level
masterpat <- master |>
  subset(Trial_type == "Pathogen") |>
  select(!c(11,12)) |>
  na.omit()

# Glimpse
glimpse(masterpat)

# Pathogen Observations per leaf level (64 plants, 3 leaves per plant = 192 leaves measured)
# masterpat2

masterpat2 <- df_list_ant2 |>
  reduce(left_join, by= "Sample_name", "E_load") |>
 mutate(Total_reads = sum(across(starts_with("OTU")))) |>
  group_by(Species) |>
  mutate(Relative_Abundance = Total_reads/sum(Total_reads)) |> 
  select(c(1:10, 584:594)) |>
  select(!c(E_load,
            Trial_Code)) |>
  relocate(Treatment, .after = Trial_type) |>
  rename(Pathogen_Damage_area = Damage_area, 
         E_load = E_load.x, 
         Trial_Code = Trial_Code.x) |>
  subset(Trial_type == "Pathogen") |>
  select(!c(12:13)) |>
  na.omit() |>
  mutate(logit_pathogenicity = logit(Pathogen_percent_damage)) 
```


The `masterant2` and `masterpat2` data frames can be a little counter-intuitive if you are not familiar with the experimental design. The `masterant2` data frame includes all the leaves of the plants that were used in the ant assay. All measurements were taken in triplicate leaves per plant per E+ and E- treatment. Hence, 70 plants (35 E+ and 35 E-) x 3 leaves per plant = 210 leaves measured. The `masterpat2` data frame includes all the leaves of the plants that were used in the pathogen assay. All measurements were taken in triplicate leaves per plant with nested treatments E+ with control and pathogen and E- with control and pathogen. This means 64 plants with the control and pathogen levels equals 128 [(32 E+ x 2) and (32 E- *2)] leaves. The pathogen damage data is at the control and pathogen leaf level and the functional trait data is at the level of the other 3 leaves. We extrapolated the functional trait data to their corresponding control and pathogen leaves. This means that the `masterpat2` data frame has 384 rows of data.


# Descriptive statistics

Evaluating non-normality of the data. Do not use `master` data set to assess the assumption of normality. It includes duplicate information for the explanatory variables. Meaning a sample and its data are paired multiples times with the OTU's that are present in it. Use either `data` or `ndata`.

Proceeding with exploring normality assumptions with `data` and `masterant`. It retains the mean values for all leaf replicates.

```{r, Normality}
# Data
# Histograms ####
# Explanatory variables
hist(data$Anthocyanins)
hist(data$Thickness..micro.m.,
     xlim = c(0,500))
hist(data$Toughness)
hist(data$LMA)


#How it would ideally look like
# QQnorms ####
qqnorm(rnorm(n = length(data$Anthocyanins..aci.), 
             mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
             sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))

# QQPlots ####
qqPlot(rnorm(n = length(data$Anthocyanins..aci.), 
             mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
             sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))

#How it actually look like             
#Using "data" set
qqPlot(data$Anthocyanins..aci.)
qqPlot(data$Thickness..micro.m.)
qqPlot(data$Toughness..lbf.)
qqPlot(data$LMA_dw)


masterant$Prop_area_loss <- masterant$Ant_percent_leafloss/100

qqPlot(masterant$Prop_area_loss)

#Using "masterant2"

qqPlot(masterant2$Ant_percent_leafloss)
qqPlot(masterant2$Anthocyanins)
qqPlot(masterant2$Thickness)
qqPlot(masterant2$Toughness)
qqPlot(masterant2$LMA)
qqPlot(masterant2$Shannon)

#Nothing has a normal distribution. It looks like it will be necessary to use a negative binomial distribution. 

# Shapiro-Wilks tests ####
hist(masterant$Ant_percent_leafloss) #Binomial 
shapiro.test(masterant$Ant_percent_leafloss) #Data deviates from the normal distribution. p-values is 0.0002607
shapiro.test(masterant$Anthocyanins) #Borderline non-normal p-value = 0.05605
shapiro.test(masterant$Thickness) #Non-normal p-value = 0.07201
shapiro.test(masterant$Toughness) #Non-normal p-value = 0.0005036
hist(masterant$Thickness)
shapiro.test(masterant$LMA) #normal p-value = 0.4742
shapiro.test(masterant$Shannon) #Normal p-value = 0.4886
hist(masterant$Shannon)
```

Somewhat better distributions. Ant_percent_leafloss is not normally distributed. It looks more like a binomial distribution. Evaluate accordingly. Conclusion from the Shapiro-Wilk tests: Some of the independent variables are not normally distributed. 

## Table 1: Summary Table
Two packages to visualize summary statistics in a table. 
```{r, table1}
# Using `gtsummary` and 'flextable' packages
summa_t1 <- tbl_summary(data |>
  group_by(Species, E_load) |>
  select(c(10:13)) |>
  rename(Treatment = E_load) |>
  mutate(Species = case_match(Species, "APEIME" ~ "A. membranacea", 
                            "CHRYCA" ~ "C. cainito", 
                            "CORDAL" ~ "C. alliodora",
                            "DYPTE" ~ "Dypterix .sp",
                            "HEISCO" ~ "H. concinna",
                            "LACPA" ~ "L. panamensis",
                            "THEOCA" ~ "T. cacao")) |>
  rename('Anthocyanins (ACI)' = Anthocyanins, 
           'Leaf Thickness (LT) (\U00B5m)'=Thickness, 
           'Leaf Punch Strength (LPS) (N mm/-1)'= Toughness, 
           'Leaf Mass per Area (LMA) (mg)' = LMA) |>
  mutate(Treatment= case_match(Treatment, "E-" ~ "E- (n = 570)", 
                        "E+" ~ "E+ (n = 544)")) |> # The sum of E- and E+ was added after iterations of tbl_summary().
    na.omit(),
  by = Species,
  missing = "no") |>
  # statistic = list(
  #   all_continuous() ~ "{mean} \u00B1 {sd}", 
  #   all_categorical() ~ "{n}")) |>
  modify_header(label = "",
                stat_1 = 'A. membranacea, n = 83',
                stat_2 = 'C. alliodora, n = 100',
                stat_3 = 'C. cainito, n = 150',
                stat_4 = 'Dypterix .sp, n = 288',
                stat_5 = 'H. concinna, n = 132',
                stat_6 = 'L. panamensis, n = 185',
                stat_7 = 'T. cacao, n = 176',
                text_interpret = "md")

  #modify_footnote(N = "N = count number", abbreviation = TRUE)
  #modify_spanning_header(all_stat_cols(stat_0= T) ~ "**Species**") 
  #modify_caption("**Table 1: Summary statistics for the leaf functional traits**")

#Turning it into a flextable object for further manipulation.
summa_t1 <- summa_t1 |>
  as_flex_table() |>
  # set_caption(
  #   as_paragraph(
  #     as_b(
  #       as_chunk("Table 1: Summary statistics for the leaf functional traits",
  #                props = fp_text_default(font.family = "Tex Gyre Termes", font.size = 12)
  #              )
  #     )
  #   ),
  # align_with_table = F) |>
  flextable::align(j = 1, align = "right", part = "all") |>
  flextable::align(j = 2:8, align = "center", part = "all") |>
  flextable::italic(j = c(2:8), italic = TRUE, part = "header") |>
  flextable::bold(i = 1, bold = TRUE, part = "header") |>
  flextable::italic(i = 1, italic = TRUE, part = "body") |>
  #padding(j = 1, padding.right= 40) |>
  flextable::width(j = 1, width = 1.5, unit = "in") |>
  flextable::font(
    i = NULL,
    j = NULL,
    fontname = "Tex Gyre Termes",
    part = "all",
    cs.family = fontname,
    hansi.family = fontname,
    eastasia.family = fontname)

# Adding some thicker borders to the table
thick <- fp_border(color = "black", style = "solid", width = 2)

summa_t1 <- summa_t1 |>
  hline_bottom(part = "body", border = thick) |>
  hline_top(part = "header", border = thick)


sect_properties <- prop_section(
  page_size = page_size(
    orient = "portrait",
    width = 8.25, height = 11.7
  ),
  type = "continuous",
  page_margins = page_mar()
)

#save_as_docx(x = summa_t1, path ="/home/baponte/Boxx/Dissertation/Leaf_Traits_Panama/Data/Aim3_Sequence_analyses/tables/summa_t1.docx", pr_section = sect_properties, align = "center")


#Huxtable attempt
#summa_t1 <- summa_t1 |>
  # as_hux() |>
  # set_italic(1, 2:8, TRUE) |>
  # set_align(3:7, 2:8, "center") |>
  # set_align(1, 1:8, "right") |>
  # set_tb_borders() |>
  #        set_width("10in") |>
  #        set_col_width(c(.7/8, .6/8, .6/8, .6/8, .6/8, .6/8, .6/8, .6/8)) |>
  # set_position("center")
  #set_font(everywhere, value = "Tex Gyre Termes")
#quick_pdf(summa_t1, width = "7in", height = "4in")

# Alignments
# summa_t1 <- set_align(summa_t1, col = 1, value = "right")
# 
# 
# # Italicize header
# summa_t1 <- set_italic(summa_t1, row = 1, TRUE)
# 
# # Bold the first row of the body
# summa_t1[1,] <- set_bold(summa_t1[1,], TRUE)
# 
# # Set width of the first column
# summa_t1 <- set_width(summa_t1, 1, 1.5)
# 
# # Set font family for the whole table
# summa_t1 <- set_font(summa_t1, everywhere, value = "Tex Gyre Termes")
summa_t1

```

## Variance Inflation Factor
### Correlations, autocorrelations, and network plots of explanatory variables

Variance inflation factors range from 1 upwards. The numerical value for VIF tells you (in decimal form) what percentage the variance (i.e. the standard error squared) is inflated for each coefficient. For example, a VIF of 1.9 tells you that the variance of a particular coefficient is 90% bigger than what you would expect if there was no multicollinearity — if there was no correlation with other predictors.

A rule of thumb for interpreting the variance inflation factor:

-   1 = not correlated.
-   Between 1 and 5 = moderately correlated.
-   Greater than 5 = highly correlated.

```{r, VIF}

vif(lm(Ant_percent_leafloss ~ Anthocyanins + Thickness + Toughness + LMA + Observed + Shannon + Total_reads, data = master))

# All explanatory variables have a VIF that is moderately correlated.
# cor()
corr <- cor(data[,c(10:13)], y = NULL, use = "complete.obs", method = "pearson")
corr
#Correlation between Anthocyanins and LMA is 0.7
cor.test(data$Anthocyanins, data$LMA, method = "pearson")
cor.test(data$Toughness, data$LMA, method = "pearson")

#Autocorrelation plot
corrplot::corrplot(corr, type="upper", order="hclust")

#To compute the matrix of p-value, a custom R function is used :

# mat : is a matrix of data
# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(corr)
head(p.mat[, 1:4])

corrplot::corrplot(corr, method = "color", type = "upper", order = "hclust",addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45, #Text label color and rotation
         # Combine with significance
         p.mat = p.mat, sig.level = 0.05, 
         # hide correlation coefficient on the principal diagonal
         diag=TRUE
         )

```

From this autocorrelation matrix I can see that the Observed richness, Shannon diversity and Total_reads have low autocorrelation the physical leaf functional traits. These three measures of community composition are somewhat correlated. Especially the Observed species richness and the Shannon diversity index (0.719735754) and Total_reads x Shannon(-0.3244523). For this reason I am going to stick to using Shannon diversity are a community traits for predicting leaf herbivory and pathogenicity. LMA is highly collinear with Anthocyanins and Toughness, while it has very low correlation with Ant_percent_leafloss. I will not include Anthocyanins in the linear models. Thickness and toughness are inversely correlated with each other. Toughness seems to have a low negative correlation with *Ant_percent_leafloss*, or *Total_leaf_area_cut*. I will not include it in the linear models.

#### Network plot

In July 5, 2020 I attempted various ways to visualize and understand the correlations between covariates using autocorrelation functions, network correlations and Variance Inflation Factor (VIF) between independent variables (explanatory variables).

```{r, Correlations and network}
#Joining data frames
joined_newdata <- left_join(ndata2, ants, by = "Sample_name") #Possibly better to use full_join()
joined_newdata <-left_join(joined_newdata, patho, by = "Sample_name")

#Data frame for correlation network of explanatory variables ####
corr.data <- joined_newdata |>
  ungroup() |>
  select(Anthocyanins, Thickness, Toughness, LMA, Ant_percent_leafloss, Pathogen_percent_damage) 

#Unite Area loss and Damage area using mutate() and coalesce() These two are a measure of leaf damage either by pathogen or herbivore
corr.data <- corr.data |>
  mutate(Area_damaged = coalesce(Ant_percent_leafloss, Pathogen_percent_damage)) |>
  select(-Ant_percent_leafloss, -Pathogen_percent_damage) |>
  na.omit()

# Looking for autocorrelations
c1 <- cor(ndata[,c(7:10)])
c1

# cor ####
#using cor() from 'stats'
cor.matrix <- as.data.frame(cor(ndata[c(7:10)]))

#Use 0.25 cut-off.
#Least correlated covariates are Toughness and Thickness: -0.124 

#Correlation matrix for correlation network using correlate() from 'corrr'

###All in one go to make correlation network plot following code from #https://www.datanovia.com/en/blog/easily-create-a-correlation-network-in-r-using-the-corrr-package/

wes_paleta <- wes_palette(name = "Darjeeling1", 3, type = "continuous")

network_traits <- corr.data |> 
  correlate(use = "pairwise.complete.obs", method = "spearman", quiet = TRUE) |>
  network_plot(min_cor = 0.0, 
               colors = c(wes_paleta), 
               curved = TRUE) +
  labs(title = "Correlation network of leaf traits" ) +
  theme(legend.text = element_text(size = 14))

network_traits
```

References

-   https://drsimonj.svbtle.com/how-to-create-correlation-network-plots-with-corrr-and-ggraph

-   https://jamesmarquezportfolio.com/correlation_matrices_in_r.html


# Leaf traits and relative abundance and total reads of OTUs

```{r, Total reads boxplot}
mycomparisons <- list(c("APEIME", "CHRYCA"), c("APEIME", "CORDAL"), c("APEIME", "DYPTE"), c("APEIME", "HEISCO"),c("APEIME", "LACPA"), c("APEIME","THEOCA"),
                      c("CHRYCA","CORDAL"), c("CHRYCA","DYPTE"),c("CHRYCA","HEISCO"), c("CHRYCA","LACPA"), c("CHRYCA", "THEOCA"),
                      c("CORDAL","DYPTE"), c("CORDAL","HEISCO"), c("CORDAL","LACPA"), c("CORDAL","THEOCA"), 
                      c("DYPTE","HEISCO"), c("DYPTE","LACPA"), c("DYPTE","THEOCA"), 
                      c("HEISCO","LACPA"), c("HEISCO","THEOCA"), c("LACPA","THEOCA"))

newname <- c("A. membranacea", "C. cainito", "C. alliodora", "Dypterix .sp", "H. concinna", "L. panamensis", "T. cacao")

names(newname) <- c("APEIME", "CHRYCA", "CORDAL", "DYPTE", "HEISCO", "LACPA", "THEOCA")
ecomparisons <- list(c(master$E_load))

#Total reads
ggplot(data = master, aes(x = E_load, y = Total_reads), group_by(Species)) +
  geom_boxplot(aes(fill = E_load), outlier.shape = NA)+
  theme_bw(base_size = 16) + 
  labs(x="", y="Total_reads")+
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24),
        axis.text.x=element_blank()) +
  annotate("text", x = 2.5, y = .65, label = "")+
  ylim(0,75000) +
  facet_wrap(~Species)

```

```{r, Relative abundance boxplot}
# By tree species
RA <- ggplot(data= master, aes(x = Species, y = Relative_Abundance)) +
  geom_boxplot(aes(fill = E_load), outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  geom_point(color="black", alpha = 0.2,size =2, position = position_jitter(w=0.05)) +
  scale_fill_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  theme_bw(base_size = 16) + 
  theme(panel.grid.major = element_line(colour = "grey")) +
  theme(panel.grid.minor = element_line(colour = "grey")) +
  theme(strip.background = element_rect(fill = "white")) +
  theme(strip.text.x = element_text(colour = "black", face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(y="Relative Abundance of OTUs (Ascomycota)")+
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24),
        axis.text.x=element_text(angle = 30)) +
  labs(caption = "*Outliers and singletons removed.") +
  scale_x_discrete(labels= mycomparisons) +
  #annotate("text", x = 2.5, y = .65, label = "") +
  stat_compare_means(comparisons = mycomparisons) +
  stat_compare_means(comparisons = ecomparisons) +
  stat_compare_means(method = "kruskal.test", label = "p.signif") 
  #ylim(0, 0.13) +
  #facet_wrap(~E_load)
RA
#ggsave(filename="Aim3_RA_Species_0706202.png", plot = RA, dpi=600, units=c("mm"), width = 300, height = 300)

```

## Figure 1a-b

```{r, RA per E_load bar and violin plot}
#| tidy: true
#Comparison of means of Relative Abundance between E+ and E- samples per tree species
#rstatix package used for pairwise t-test
master |>
  group_by(Species) |>
  pairwise_t_test(Relative_Abundance ~ E_load,
         p.adjust.method = "BH",
  paired = TRUE,
  #var.equal = F,
  alternative = "two.sided",
  mu = 0,
  conf.level = 0.95, 
  detailed = TRUE)

#ggpubr package used for t.tests and plotting t-test comparisons
compare_means(Relative_Abundance ~ E_load,
         data = master,
         method = "t.test",
         p.adjust.method = "BH",
  paired = TRUE,
  group.by = "Species")
  #var.equal = F,
#Roughly the same outcome as pairwise_t_test.
#Report with `compare_means` because it is easier to plot with `ggpubr` package.


# RA per E_load
RAE <- ggplot(data= master, aes(x = E_load, y = Relative_Abundance)) +
  geom_violin(aes(fill = E_load)) +
  #geom_boxplot(width=0.1, color="grey30", alpha=0.2) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  geom_point(color="grey15", alpha = 0.4,size = 2, position = position_jitter(w=0.05)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  theme_classic(base_size = 12)+
  theme(panel.grid.major = element_line(colour = "grey"),
        panel.grid.minor = element_line(colour = "grey"),
        strip.background = element_rect(fill = "white"),
        axis.line.x.bottom = element_blank(), 
        strip.text.x = element_text(colour = "grey15", face = "italic"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(size = 14),
        plot.title = element_text(color="black", size = 14, face="bold"),
        axis.text.x=element_blank()) +
  labs(x="", y="Relative Abundance of Ascomycota", face = "bold")+
  theme() +
  #labs(caption = "*Outliers and singletons removed.") +
  stat_compare_means(comparisons = list(c("E-", "E+")),
                     method = "t.test",
                     label = "p.signif",
                     paired = T,
                     label.y = 25, 
                     bracket.size = 0.65) +
  facet_wrap(~Species, labeller = as_labeller(newname))
  
#RAE


RAE_bar <- ggplot(data= master, aes(x = Species, y = Relative_Abundance)) +
  geom_bar(stat="identity", aes(fill = E_load), position = "stack") +
  scale_fill_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 14)+
  theme(strip.text.x = element_text(colour = "grey15", face = "italic"),
        panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(x="", y="Relative Abundance of Ascomycota", face = "bold")+
  theme(legend.position="right",
        legend.title = element_blank(),
        legend.text = element_text(size = 14),
        plot.title = element_text(color="black", size = 14, face="bold"),
        axis.text.x=element_text(face = "italic", hjust = 1, angle = 30))


#RAE_bar

# Arranged as a grid
fig1<- ggarrange(RAE, RAE_bar, nrow = 1, ncol=2, widths = c(1.5, 1), common.legend = TRUE, legend="bottom",label.x = 0, vjust = 1, labels=c("(a)", "(b)"))

fig1


# Saving
#ggsave(filename="./figures/Aim3_Fig1_02JAN2024.png", plot = fig1, dpi=600, units=c("mm"), width = 200, height = 180, bg ="white")
#
#Previously saved as Aim3_RA_Eload_SEPT182023.png
```

## Figure S1
```{r, suppfig_1}
Abun7a <- ggplot(data= data |>
                      group_by(Species, Sample_name, E_load, Leaf_ID) |>
                      summarise(Abun_7 = mean(Abun_7)),
                     aes(x = E_load, y = Abun_7)) +
  geom_violin(aes(fill = E_load)) +
  #geom_boxplot(width=0.1, color="grey30", alpha=0.2) +
  geom_crossbar(stat="summary", 
                fun = mean, 
                fun.max = mean,
                fun.min = mean,  
                fatten = 2, 
                width = 0.5) +
  geom_point(color="grey15", 
             alpha = 0.4,
             size = 2, 
             position = position_jitter(w=0.05)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_y_continuous(labels = scales::percent) +
theme_classic(base_size = 14)+
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #axis.line.x.bottom = element_blank(), 
        strip.text.x = element_text(colour = "grey15", face = "italic"),
        panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(x="", y="Endophyte colonization (%)", face = "bold")+
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(size = 14),
        plot.title = element_text(color="black", size = 14, face="bold"),
        axis.text.x=element_blank()) +
  stat_compare_means(comparisons = list(c("E-", "E+")),
                     method = "t.test",
                     label = "p.signif", bracket.size = 0.65) 
  #facet_wrap(~Species, labeller = as_labeller(newname))
 Abun7a  
 
Abun7b <- ggplot(data= data |>
                      group_by(Species, Sample_name, E_load, Leaf_ID) |>
                      summarise(Abun_7 = mean(Abun_7)),
                     aes(x = E_load, y = Abun_7)) +
  geom_violin(aes(fill = E_load)) +
  #geom_boxplot(width=0.1, color="grey30", alpha=0.2) +
  geom_crossbar(stat="summary", 
                fun = mean, 
                fun.max = mean,
                fun.min = mean,  
                fatten = 2, 
                width = 0.5) +
  geom_point(color="grey15", 
             alpha = 0.4,
             size = 2, 
             position = position_jitter(w=0.05)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_y_continuous(expand = expansion(mult = 0.1), 
                     breaks = c(0, 0.25, 0.50, 0.75, 1),
                     labels = scales::percent) +
  #scale_y_continuous(labels = scales::percent) +
theme_classic(base_size = 14)+
  theme(
        panel.grid.major = element_line(colour = "grey"),
        panel.grid.minor = element_line(colour = "grey"),
        strip.background = element_rect(fill = "white"),
        axis.line.x.bottom = element_blank(),
        strip.text.x = element_text(colour = "grey15", face = "italic"),
        panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(x="", y="Endophyte colonization (%)", face = "bold")+
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(size = 14),
        plot.title = element_text(color="black", size = 14, face="bold"),
        axis.text.x=element_blank()) +
  stat_compare_means(comparisons = list(c("E-", "E+")),
                     method = "t.test",
                     label = "p.signif", label.y = 1.03, bracket.size = 0.65) +
  facet_wrap(~Species, labeller = as_labeller(newname))


Abun7b  

# Figure S1a-S1b
suppfig_1 <- ggarrange(Abun7a, Abun7b, nrow = 1, ncol=2, common.legend = TRUE, legend="bottom", labels = c("(a)", "(b)"))
suppfig_1


#ggsave(filename="./figures/Aim3_FigS1_07JAN2024.png", plot = suppfig_1, dpi=600, units=c("mm"), width = 250, height = 200, bg ="white")
```

## Figure S2-S7
```{r, Functional traits violins}
mycomparisons <- list(c("APEIME", "CHRYCA"), c("APEIME", "CORDAL"), c("APEIME", "DYPTE"), c("APEIME", "HEISCO"),c("APEIME", "LACPA"), c("APEIME","THEOCA"),
                      c("CHRYCA","CORDAL"), c("CHRYCA","DYPTE"),c("CHRYCA","HEISCO"), c("CHRYCA","LACPA"), c("CHRYCA", "THEOCA"),
                      c("CORDAL","DYPTE"), c("CORDAL","HEISCO"), c("CORDAL","LACPA"), c("CORDAL","THEOCA"), 
                      c("DYPTE","HEISCO"), c("DYPTE","LACPA"), c("DYPTE","THEOCA"), 
                      c("HEISCO","LACPA"), c("HEISCO","THEOCA"), c("LACPA","THEOCA"))

newname <- c("A. membranacea", "C. cainito", "C. alliodora", "Dypterix .sp", "H. concinna", "L. panamensis", "T. cacao")

names(newname) <- c("APEIME", "CHRYCA", "CORDAL", "DYPTE", "HEISCO", "LACPA", "THEOCA")

# Anthocyanins by endophyte load an species
ACIa <- ggplot(data = master, aes(x = E_load, y = Anthocyanins, fill = E_load)) +
  geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 16) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_blank(),
        legend.position="right", 
        legend.text = element_text(size = 14)) +
  labs(x="", y=expression(paste("ACI (% ", italic("A") [lambda]," at 931 nm / % ", italic("A") [lambda]," at 530 nm)"))) +
  theme(legend.position="right", 
        legend.text = element_text(size = 14)) +
  #labs(caption = "*Outliers and singletons removed.") +
  
  #annotate("text", x = 2.5, y = .65, label = "") +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     paired = T,
                     comparisons =list(c("E-", "E+")),
                     bracket.size = 0.8)

ACIa


ACIb <- ggplot(data = master, aes(x = Species, y = Anthocyanins, fill = E_load)) +
  geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  scale_y_continuous(limits = c(100, 300)) +
  theme_classic(base_size = 16) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_text(face = "italic", hjust = 1, angle = 30),
        legend.position="right", 
        legend.text = element_text(size = 14)) +
  labs(x="", y=expression(paste("ACI (% ", italic("A") [lambda]," at 931 nm / % ", italic("A") [lambda]," at 530 nm)"))) +
  #theme(legend.position="right", 
        #legend.text = element_text(size = 14)) +
  #labs(caption = "*Outliers and singletons removed.") +
  #annotate("text", x = 2.5, y = .65, label = "") +
  stat_compare_means(label = "p.signif", 
                     method = "anova", 
                     paired = T)

ACIb

# Figure S1a S1b
suppfig_1 <- ggarrange(ACIa, ACIb, nrow = 1, ncol=2, common.legend = TRUE, legend="bottom", labels = c("(a)", "(b)"))
suppfig_1


# Leaf thickness by endophyte load and species

LTa <- ggplot(data = master, aes(x = E_load, y = Thickness, fill = E_load)) +
  geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  scale_y_continuous(limits = c(100, 300)) +
  theme_classic(base_size = 16) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_blank(),
        legend.position="right", 
        legend.text = element_text(size = 14)) +
  labs(x="", y= expression(paste("Leaf thickness (",mu,"m)"))) +
  theme(legend.position="right", 
        legend.text = element_text(size = 14)) +
  #labs(caption = "*Outliers and singletons removed.") +
  
  #annotate("text", x = 2.5, y = .65, label = "") +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     paired = T,
                     comparisons =list(c("E-", "E+")),
                     bracket.size = 0.8)

LTa


LTb <- ggplot(data = master, aes(x = Species, y = Thickness, fill = E_load)) +
  geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  scale_y_continuous(limits = c(100, 300)) +
  theme_classic(base_size = 16) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_text(face = "italic", hjust = 1, angle = 30),
        legend.position="right", 
        legend.text = element_text(size = 14)) +
  labs(x="", y= expression(paste("Leaf thickness (",mu,"m)"))) +
  #theme(legend.position="right", 
        #legend.text = element_text(size = 14)) +
  #labs(caption = "*Outliers and singletons removed.") +
  #annotate("text", x = 2.5, y = .65, label = "") +
  stat_compare_means(label = "p.signif", 
                     method = "anova",
                     paired = T)
LTb

# Figure S2a S2b
suppfig_2 <- ggarrange(LTa, LTb, nrow = 1, ncol=, common.legend = TRUE, legend="bottom", labels = c("(a)", "(b)"))
suppfig_2


# Table of results: Thickness T-tests

thickness_comparisons <- compare_means(Thickness ~ Species, data = master, method = "t.test")
thickness_cp_table <- as_hux(thickness_comparisons, detailed = TRUE)
thickness_cp_table


# res <- manova(cbind(Anthocyanins, Thickness, Toughness, LMA) ~ Species, data = master)
#ggsave(filename="Aim3_LT_Species_07062022.png", plot = LT, dpi=600, units=c("mm"), width = 300, height = 300)

# Figure S3
# Leaf toughness (lbf) by  endophyte load and species with data (data) ####
LPSa <- ggplot(data = master, aes( x = E_load, y = Toughness, fill = E_load)) +
geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 16) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_blank(),
        legend.position="right", 
        legend.text = element_text(size = 14)) +
  labs(x="", y= expression(paste("Leaf punch strength(N mm","^-1)"))) +
  #labs(caption = "*Outliers and singletons removed.") +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     paired = T,
                     comparisons =list(c("E-", "E+")),
                     bracket.size = 0.8) 
#LPSa


LPSb <- ggplot(data = master, aes( x = Species, y = Toughness, fill = E_load)) +
geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 16) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_text(face = "italic", hjust = 1, angle = 30),
        legend.position="right", 
        legend.text = element_text(size = 14)) +
  labs(x="", y= expression(paste("Leaf punch strength(N mm","^-1)"))) +
  #labs(caption = "*Outliers and singletons removed.") +
  stat_compare_means(label = "p.signif",
                     method = "anova",
                     paired = T) +
  ylim(0.10, 1) 
#LPSb

# Figure S3a S3b
# 
suppfig_3 <- ggarrange(LPSa, LPSb, nrow = 1, ncol=2, common.legend = TRUE, legend="bottom", labels = c("(a)", "(b)"))
suppfig_3
#ggsave(filename="./figures/Aim3_FigS3_03JAN2024.png", plot = suppfig_3, dpi=600, units=c("mm"), width = 250, height = 200, bg ="white")
#Previously named Aim3_LPS_Species_07062022.png


# Figure S4a-b
# Leaf mass per area (LMA) by  endophyte load and species
LMAa <- ggplot(data = master, aes(x = E_load, y = LMA, fill = E_load)) +
  geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 16) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_blank(),
        legend.position="right", 
        legend.text = element_text(size = 14)) +
  labs(x="", y= expression(paste("LMA (mg ",mm^-2, ")"))) +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     paired = T,
                     comparisons =list(c("E-", "E+")),
                     bracket.size = 0.8)
LMAa

LMAb <- ggplot(data = master, aes( x = Species, y = LMA, fill = E_load)) +
geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 5, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 16) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_text(face = "italic", hjust = 1, angle = 30),
        legend.position="right", 
        legend.text = element_text(size = 14)) +
  labs(x="", y= expression(paste("LMA (mg ",mm^-2, ")"))) +
  #labs(caption = "*Outliers and singletons removed.") +
  stat_compare_means(label = "p.signif", 
                     method = "anova",
                     paired = T)

LMAb

suppfig_4 <- ggarrange(LMAa, LMAb, nrow = 1, ncol=2, common.legend = TRUE, legend="bottom", labels = c("(a)", "(b)"))
suppfig_4

ggsave(filename="./figures/Aim3_FigS4_04JAN2024.png", plot = suppfig_4, dpi=600, units=c("mm"), width = 250, height = 200, bg ="white")


# Diversity
DVI <- ggplot(data= master, aes(x = E_load, y = Shannon)) +
  geom_violin(aes(fill = E_load), outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  geom_point(color="black", alpha = 0.2,size =2, position = position_jitter(w=0.05)) +
  scale_fill_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  theme_bw(base_size = 16) + 
  theme(panel.grid.major = element_line(colour = "grey")) +
  theme(panel.grid.minor = element_line(colour = "grey")) +
  theme(strip.background = element_rect(fill = "white")) +
  theme(strip.text.x = element_text(colour = "black", face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(x="", y="Shannon Diversity Index of OTUs (Ascomycota)")+
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24),
        axis.text.x=element_blank()) +
  labs(caption = "*Outliers and singletons removed.") +
  annotate("text", x = 2.5, y = .65, label = "") +
  stat_compare_means(comparisons = mycomparisons ) +
  stat_compare_means(method = "kruskal.test", label = "p.signif") +
  facet_wrap(~Species)
DVI
#ggsave(filename="Aim3_DV_Eload_07122022.png", plot = DVI, dpi=600, units=c("mm"), width = 300, height = 300)
```

I HAVE TO INVESTIGATE FURTHER AS TO WHY THIS LAST GGPLOT FOR LMA GIVE THIS OUTPUT: Warning messages:1: Removed 34 rows containing non-finite values (stat_boxplot). 2: Removed 7 rows containing missing values (geom_text).

This problem was due to having values out of the ylab.

```{r, suppfig_6}
#| echo: false
#| eval: true
#| tidy: true
#| warning: false
#| fig.height: 6
#| fig.width: 6
#| fig.cap: "Distributions of values and means of herbivory (%) damage caused by *Atta colombica* in treatment groups (*E-* and *E+*) and tree species. a) Comparison of herbivory (%) means between treatment groups across individuals of all species. Statistical significance was calculated using a two-sided Student's t-Test. b) Comparison of herbivory (%) means between treatment types of each species. Statistical significance was calculated with an analysis of variance (ANOVA). Pink filled violins represent low FEF group (*E-*) and yellow filed violins represent high FEF group (*E+*). Significance levels are represented by *ns* (not significant) and asterisks [*p* = 0.05 (\\*), *p* = 0.01 (\\**), and *p* = 0.001 (\\***)]."

#Comparison of means of Herbivory(%) between E+ and E- samples per tree species
#rstatix package used for pairwise t-test
suppfig6_pairwise_t_test <- master |>
  group_by(Species) |>
  pairwise_t_test(Ant_percent_leafloss ~ E_load,
         p.adjust.method = "BH",
  paired = TRUE,
  #var.equal = F,
  alternative = "two.sided",
  mu = 0,
  conf.level = 0.95, 
  detailed = TRUE)

#ggpubr package used for t.tests and plotting t-test comparisons
#E+ vs E- for all specie. To compare means of pathogen damage (%) between E+ and E- samples per species un-comment `group.by = "Species"` and change method to  "anova" in compare_means.
suppfig6a_compare_means <- compare_means(Ant_percent_leafloss ~ E_load,
         data = master,
         #group.by = "Species",
         method = "t.test",
         p.adjust.method = "BH",
  paired = TRUE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)
#Roughly the same outcome as pairwise_t_test.
suppfig6b_compare_means <- compare_means(Ant_percent_leafloss ~ E_load,
         data = master,
         group.by = "Species",
         method = "t.test",
         p.adjust.method = "BH",
  paired = TRUE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)
#Report with `compare_means` because it is easier to plot with `ggpubr` package.

#Since `compare_means` does not provide a test statistic, I will use `t.test` to report the test statistic.
x <- subset(master, E_load == "E-", na.rm = TRUE)
y <- subset(master, E_load == "E+", na.rm = TRUE)
  
t.test(
  x$Ant_percent_leafloss, y$Ant_percent_leafloss,
  method = "t.test",
  p.adjust.method = "BH",
  paired = TRUE,
  alternative = "two.sided",
  mu = 0,
  var.equal = FALSE,
  conf.level = 0.95
)

suppfig6_summ_stats <- master |>
  group_by(E_load) |>
  summarise(count = n(),
    mean = mean(Ant_percent_leafloss, na.rm = TRUE),
            sd = sd(Ant_percent_leafloss, na.rm = TRUE),
            se = sd(Ant_percent_leafloss, na.rm = TRUE)/sqrt(n()),
            ci = 1.96 * se) |>
  as.data.frame()
mean(master$Ant_percent_leafloss, na.rm = TRUE)
# Fig. S6a
herb_violin_a <- ggplot(data = master, aes(x = E_load, y = Ant_percent_leafloss, fill = E_load)) +
  geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary",
               fun = mean,
               fun.max = mean,
               fun.min = mean,
               alpha = 0.3,
               size = 0.3,
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
#  scale_y_continuous(limits = c(100, 300)) +
  theme_classic(base_size = 12) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_blank(),
        legend.position="right", 
        legend.text = element_text(size = 12)) +
  labs(x="", y= expression(paste("Herbivory (%)"))) +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     paired = T,
                     comparisons =list(c("E-", "E+")),
                     bracket.size = 0.8)

#herb_violin_a

#Fig. S6b
herb_violin_b <-  ggplot(data = master, aes( x = Species, y = Ant_percent_leafloss, fill = E_load)) +
geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 12) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_text(face = "italic", hjust = 1, angle = 30),
        legend.position="right", 
        legend.text = element_text(size = 12)) +
  labs(x="", y= expression(paste("Herbivory (%)"))) +

  stat_compare_means(label = "p.signif", 
                     method = "anova",
                     paired = T)
#herb_violin_b

aov(Ant_percent_leafloss ~ Species, data = master)

# Figure S6a-S6b
suppfig_6 <- ggarrange(herb_violin_a, herb_violin_b, nrow = 1, 
                       ncol=2, 
                       label.x = -0.015, vjust = 1, 
                       common.legend = TRUE,
                       legend="bottom", 
                       labels = c("(a)", "(b)"))

suppfig_6
#ggsave(filename="./figures/Aim3_FigS6_15JAN2024.png", plot = suppfig_6, dpi=600, units=c("mm"), width = 250, height = 200, bg ="white")
```


```{r, suppfig_7}

#| echo: false
#| eval: true
#| tidy: true
#| warning: false
#| fig.height: 6
#| fig.width: 6
#| fig.cap: "Distributions of values and means of pathogen (%) damage caused by *Calonectria* sp. in treatment groups (*E-* and *E+*) and tree species. a) Comparison of pathogen (%) means between treatment groups across individuals of all species. Statistical significance was calculated using a two-sided Student's t-Test. b) Comparison of pathogen (%) means between treatment types of each species. Statistical significance was calculated with an analysis of variance (ANOVA). Pink filled violins and points represent low FEF group (*E-*) and yellow filed violins represent high FEF group (*E+*). Marron filled violins represent control leaves and blue filled violins represent pathogen treated leaveds. Significance levels are represented by *ns* (not significant) and asterisks [*p* = 0.05 (\\*), *p* = 0.01 (\\**), and *p* = 0.001 (\\***)]."

#Comparison of means of Pathogen damage (%) between E+ and E- samples per tree species
#rstatix package used for pairwise t-test
suppfig7_pairwise_t_test <- master |>
  group_by(E_load) |>
  pairwise_t_test(Pathogen_percent_damage ~ Treatment,
         p.adjust.method = "BH",
  paired = TRUE,
  #var.equal = F,
  alternative = "two.sided",
  mu = 0,
  conf.level = 0.95, 
  detailed = TRUE) 

#ggpubr package used for t.tests and plotting t-test comparisons
#E+ vs E- for all specie. To compare means of pathogen damage (%) between E+ and E- samples per species un-comment `group.by = "Species"` and change method to  "anova" in compare_means.
suppfig7a_compare_means <- compare_means(Pathogen_percent_damage ~ E_load,
         data = master,
         #group.by = "Species",
         method = "t.test",
         p.adjust.method = "BH",
  paired = TRUE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)
#Roughly the same outcome as pairwise_t_test.
suppfig7b_compare_means <- compare_means(Pathogen_percent_damage ~ E_load,
         data = master,
         group.by = "Species",
         method = "anova",
         p.adjust.method = "BH",
  paired = TRUE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)

suppfig7_summ_stats <- master |>
  group_by(E_load, Treatment) |>
  summarise(count = n(),
    mean = mean(Pathogen_percent_damage),
            sd = sd(Pathogen_percent_damage),
            se = sd(Pathogen_percent_damage)/sqrt(n()),
            ci = 1.96 * se) |>
  as.data.frame()
#Report with `compare_means` because it is easier to plot with `ggpubr` package.
#Since `compare_means` does not provide a test statistic, I will use `pairwise_t_test` to report the test statistic.

# Fig. S7a
patho_violin_a <- ggplot(data = master, aes(x = E_load, y = Pathogen_percent_damage, fill = Treatment)) +
  geom_violin() +
  geom_point(aes(color = E_load),position = position_jitterdodge(dodge.width = 0, jitter.width = 0.2),
             alpha = 0.5, size = 2) +
  geom_crossbar(stat="summary",
               fun = mean,
               fun.max = mean,
               fun.min = mean,
               alpha = 0.3,
               linewidth = 0.3,
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Pathogen treatment ", values= met.brewer("Egypt", n = 2, type = "discrete")) +
  scale_color_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  #scale_shape_manual(name = "Treatment", labels = c("E-", "E+"), values = c(16, 17)) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 12) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        #axis.text.x=element_blank(),
        legend.position="right", 
        legend.text = element_text(size = 12)) +
  labs(x="", y= expression(paste("Pathogen damage (%)"))) +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     paired = T,
                     label.y = 80) +
  stat_compare_means(label = "p.signif",
                     method = "t.test",
                     paired = T,
                     comparisons =list(c("E-", "E+")),
                     bracket.size = 0.8)

patho_violin_a

#Fig. S7b
patho_violin_b <-  ggplot(data = master, aes( x = Species, y = Pathogen_percent_damage, fill = E_load)) +
geom_violin() +
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.2),
             alpha = 0.3, color = "grey30", size = 2) +
  geom_crossbar(stat="summary", 
               fun = mean, 
               fun.max = mean, 
               fun.min = mean,
               alpha = 0.3, 
               size = 0.3, 
               width = 0.7,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(name = "Treatment ", values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_x_discrete(labels=c(newname)) +
  theme_classic(base_size = 12) +
  theme(
        #panel.grid.major = element_line(colour = "grey"),
        #panel.grid.minor = element_line(colour = "grey"),
        #strip.background = element_rect(fill = "white"),
        #strip.text.x = element_text(colour = "black", face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        axis.text.x=element_text(face = "italic", hjust = 1, angle = 30),
        legend.position="right", 
        legend.text = element_text(size = 12)) +
  labs(x="", y= expression(paste("Pathogen damage (%)"))) +

  stat_compare_means(label = "p.signif", 
                     method = "anova",
                     paired = T)
#patho_violin_b




# Figure S7a-S7b
suppfig_7 <- ggarrange(patho_violin_a, patho_violin_b, nrow = 1, 
                       ncol=2, 
                       label.x = -0.015, vjust = 1,
                       widths = c(1.2, 1),
                       common.legend = FALSE,
                       legend="bottom", 
                       labels = c("(a)", "(b)"))

suppfig_7
#ggsave(filename="./figures/Aim3_FigS7_15JAN2024.png", plot = suppfig_7, dpi=600, units=c("mm"), width = 250, height = 200, bg ="white")
```

# Principal Component Analysis (PCA) of leaf functional traits

The idea here is to see which leaf functional trait and community diversity traits (relative abundance, richness and diversity) impact herbivory and pathogenicity. Only using LMA, thickness and toughness, as these covariates are orthagonal to each other in PCA analysis. Reminder that de `ndata`'s experimental unit is the leaf, not the plant.

## Fig. 4: Grid PCA plot
### Full PCA

```{r, Full PCA, tidy = FALSE}
# PCA using covariates to explain species richness/abundance ####
data.pca <- ndata[c(7,8,9,10)]
data.pca <- data.pca |>
  rename(ACI = Anthocyanins, LT = Thickness, LPS = Toughness) #Renaming columns for plotting purposes.

###Run this to create pca with prcomp function
pca<-prcomp(data.pca, scale=TRUE)
pca$rotation=-pca$rotation
pca$x=-pca$x

#Checking the PCA
plot(pca,type = "lines")
biplot(pca) # Base type PCA

# PCA using autoplot() and prcomp()and modifying with ggplot syntax ####
auto <- autoplot((pca), data = data.frame(ndata), # For some reason this functions require data to be data= data.frame()
         alpha=0, #Setting alpha to zero render the automatic circle point null.Manipulate shapes with geom_point(). 
         loadings = TRUE,loadings.colour = "black",
         loadings.label=TRUE, loadings.label.colour="black",
         loadings.label.size= 4, size = 7, loadings.label.vjust = 1, 
         loadings.label.hjust = 1) + 
  geom_point(aes(fill = Species, color = Species, shape = E_load), alpha = 0.6, size = 3) +
  geom_hline(yintercept = 0, colour = "gray45") +
  geom_vline(xintercept = 0, colour = "gray45") +
  scale_color_manual(labels=c("A. membranacea", "C. cainito", "C. alliodora", "Dypterix .sp", "H. concinna", "L. panamensis", "T. cacao"),values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  stat_ellipse(aes(color=Species), geom = "path", size = 1, position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
  scale_fill_discrete(labels = c("A. membranacea", "C. cainito", "C. alliodora", "Dypterix .sp", "H. concinna", "L. panamensis", "T. cacao")) +
  scale_shape_manual(name = "Treatment", labels = c("E-", "E+"), values = c(16, 17)) +
  theme_classic(base_size = 16) +
  #labs(title = "(a)") + 
  theme(plot.title = element_text(color="black", size = 14, face="bold"),
        legend.title = element_text(face = "bold"),
        legend.text = element_text(color="black", size = 14, face="italic"))

#caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. All leaf replicates per species ("~ italic("n") ~ "= 467).") #This goes in the labs() arguments

auto$layers <- c(auto$layers, auto$layers[[2]], auto$layers[[3]]) # This adds/copies layers 2-3 and overlays them. It makes the arrows be on top of the points. There must be a better ways of doing this.

#Checking if all is good.
auto <- auto +
  theme(plot.caption = element_text(size = 6, hjust = 1, vjust = 1))
auto 

#ggsave(filename="./figures/Aim3_PCA_SEPT252023.png", plot = auto, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```

### Ant PCA

Data points represent leafs of plants used in ant assays.

```{r, Ant PCA}}
# PCA using covariates to explain species richness/abundance ####
ant_pcadata <- masterant2[c(7,8,9,10)]
ant_pcadata <- ant_pcadata |>
  rename(ACI = Anthocyanins, LT = Thickness, LPS = Toughness) #Renaming columns for plotting purposes.


###Run this to create pca with prcomp function
ant.pca <-prcomp(ant_pcadata, scale=TRUE)
ant.pca$rotation=-ant.pca$rotation
ant.pca$x=-ant.pca$x

# Plot
auto_ant <- autoplot((ant.pca), data = data.frame(masterant2), # For some reason this functions require data to be data= data.frame()
         alpha=0, #Setting alpha to zero render the automatic circle point null.Manipulate shapes with geom_point(). 
         loadings = TRUE,loadings.colour = "black",
         loadings.label=TRUE, loadings.label.colour="black",
         loadings.label.size= 4, size = 7, loadings.label.vjust = 0, 
         loadings.label.hjust = 1.2) + 
  geom_point(aes(fill = Species, color = Species, shape = E_load), alpha = 0.6, size = 2.2) +
  geom_hline(yintercept = 0, colour = "gray45") +
  geom_vline(xintercept = 0, colour = "gray45") +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  stat_ellipse(aes(color=Species), geom = "path", size = 1, position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
  theme_bw(base_size = 12) +
  labs(title = "b") +
  theme(plot.title = element_text(color="black", size = 14, face="bold")) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
# caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. All leaf replicates per species ("~ italic("n") ~ "= 210).")
 
auto_ant$layers <- c(auto_ant$layers, auto_ant$layers[[2]], auto_ant$layers[[3]]) # This adds/copies layers 2-3 and overlays them. It makes the arrows be on top of the points. There must be a better ways of doing this.

#Checking if all is good.
auto_ant <- auto_ant +
  theme(plot.caption = element_text(size = 6, hjust = 1, vjust = 1))
auto_ant

#ggsave(filename="./figures/Aim3_Ant_PCA_07102023.png", plot = auto_ant, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```

### Pathogen PCA

Data points represent leafs of plants used in pathogen assays.

```{r, Pathogen PCA}
# PCA using covariates to explain species richness/abundance ####
pat_pcadata <- masterpat2[c(8,9,10,11)]
pat_pcadata <- pat_pcadata |>
  rename(ACI = Anthocyanins, LT = Thickness, LPS = Toughness) #Renaming columns for plotting purposes.


###Run this to create pca with prcomp function
pat.pca <-prcomp(pat_pcadata, scale=TRUE)
pat.pca$rotation=-pat.pca$rotation
pat.pca$x=-pat.pca$x

# Plot
auto_pat <- autoplot((pat.pca), data = data.frame(masterpat2), # For some reason this functions require data to be data= data.frame()
         alpha=0, #Setting alpha to zero render the automatic circle point null.Manipulate shapes with geom_point(). 
         loadings = TRUE,loadings.colour = "black",
         loadings.label=TRUE, loadings.label.colour="black",
         loadings.label.size= 4, size = 7, loadings.label.vjust = 0, 
         loadings.label.hjust = 1.2) + 
  geom_point(aes(fill = Species, color = Species, shape = E_load), alpha = 0.6, size = 2.2) +
  geom_hline(yintercept = 0, colour = "gray45") +
  geom_vline(xintercept = 0, colour = "gray45") +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  stat_ellipse(aes(color=Species), geom = "path", size = 1, position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
  theme_bw(base_size = 12) +
  labs(title = "c") +
  theme(plot.title = element_text(color="black", size = 14, face="bold")) + 
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
# caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. All leaf replicates per species ("~ italic("n") ~ "= 210).")

auto_pat$layers <- c(auto_pat$layers, auto_pat$layers[[2]], auto_pat$layers[[3]]) # This adds/copies layers 2-3 and overlays them. It makes the arrows be on top of the points. There must be a better ways of doing this.

#Checking if all is good.
auto_pat <- auto_pat +
  theme(plot.caption = element_text(size = 6, hjust = 1, vjust = 1))
auto_pat

#ggsave(filename="./figures/Aim3_Pathogen_PCA_08162023.png", plot = auto_pat, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```


### Grid PCA
```{r, Grid PCA}
#| eval: false
#| tidy: true
grid_pca <- ggarrange(auto, auto_ant, auto_pat, nrow = 1, ncol=3, common.legend = TRUE, legend="bottom")

grid_pca
# Adding caption
# ant_caption <- expression("*All individual leaves per individual per tree species included ("~ italic("n") ~ "= 210).")
# ant_pca_with_caption <- annotate_figure(antpca_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)
# 
# ant_pca_with_caption

#ggsave(filename = "./figures/Aim3_Fig2_02JAN2024.png", plot = grid_pca, dpi=300, units=c("mm"), width = 200, height = 120, bg = "white")
#Previously called Aim3_GridPCA_SEPT182023.png
```

## PCA: Simple linear models with PC1 and PC2

### Ants

Here I take the loading (PCs) from the **Ant Full PCA** and join them to the ant herbivory (leafloss) data. Thus being able to perform linear regressions from this new dataset (`ant_pca` + `masterant2`).

```{r, Lm PCA data}
# PCA loadings (rotations) data frame
ant.pci<-data.frame(ant.pca$x) #Species = ndata$Species not included.
glimpse(ant.pci)

# joined data frame for PC llinear regressions

ant_pcalm <- masterant2[c(1,2,5,12, 17)]

ant_pcalm <- cbind(ant_pcalm, ant.pci) #Both data sets have 467 observations
```

The functions `prcomp` and `princomp` are both possible to use for this analysis. The `prcomp` stores the "scores" as `x`, while `princomp` stores them as `scores`. Useful to know when extracting the data from it for linear regressions. The function `princomp` uses Eigen decomposition of the covariance and correlations between samples. The `prcomp` uses the singular value decomposition between variables.

#### Ants \~ PC1 & PC2

```{r, Ant PC1-2}
# Formatting formula for p value
format.p <- function(p, precision = 0.001) {
  digits <- -log(precision, base = 10)
  p <- formatC(p, format = 'f', digits = digits)
  if (p < 0.001) {
    p = paste0('< ', precision)}
  if (p >= 0.001) {
    p = paste0('= ', p)    }
  sub("0", "0", p)
}

lmpc1 <- lm(Ant_percent_leafloss ~ PC1, data = ant_pcalm)
summary(lmpc1)
# PC1
# Formatted p-value
ant_p1 <- cor.test(ant_pcalm$Ant_percent_leafloss, ant_pcalm$PC1)$p.value

ant_p1 = format.p(ant_p1) # This is just to make the p-value nicer. 

## Plot PC1
       
ant_pc1 <- ggplot(ant_pcalm, aes(PC1, Ant_percent_leafloss)) +
  geom_jitter(aes(color = Species, shape = E_load), size = 3, alpha = 0.6) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.75) +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 7,
                        aes(label = paste(..eq.label.., sprintf("italic('p')~'%s'", ant_p1), 
                                          sep = "~~~~"))) +
  scale_color_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix .sp", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   scale_shape_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = c(16, 17)) +
  theme_minimal(base_size = 16) +
  labs(y = "Herbivory (%)", caption = "") +
  theme(legend.text = element_text(color="black", face="italic"))
  #guides(color = "none")  +      #To turn off color legend
  #guides(fill = "none") + #To turn off fill legend
  #guides(shape = "none")

#ant_pc1

#ggsave(filename="./figures/Aim3_AntPC1_JUL102023.png", plot = ant_pc1, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")


# PC2
# Formatted p-values

ant_p2 <- cor.test(ant_pcalm$Ant_percent_leafloss, ant_pcalm$PC2)$p.value

ant_p2 =format.p(ant_p2) # This is just to make the p-value nicer. 

## Plot PC2
lmpc2 <- lm(Ant_percent_leafloss ~ PC2, data = ant_pcalm)

ant_pc2 <- ggplot(ant_pcalm, aes(PC2, Ant_percent_leafloss)) +
  geom_jitter(aes(color = Species, shape = E_load), size = 3, alpha = 0.6) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.75) +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 7,
                        aes(label = paste(..eq.label.., sprintf("italic('p')~'%s'", ant_p2), 
                                          sep = "~~~~"))) +
  scale_color_manual(labels=c("A. membranacea", 
                            "C. cainito", 
                            "C. alliodora", 
                            "Dypterix .sp", 
                            "H. concinna", 
                            "L. panamensis", 
                            "T. cacao"),
                     values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme_minimal(base_size = 16) +
  labs(y = "Herbivory (%)", caption = "") +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
  
  
#ant_pc2

#ggsave(filename="./figures/Aim3_AntPC2_JUL102023.png", plot = ant_pc2, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```

### Pathogen

Here I take the loading (PCs) from the **Pathogen Full PCA** and join them to the fungal pathogenicity (leaf damage) data. Thus being able to perform linear regressions from this new dataset (pat_pac + masterpat2).

```{r, Lm PCA data}
# PCA loadings (rotations) data frame
pat.pci<-data.frame(pat.pca$x) #Species = ndata$Species not included.
glimpse(pat.pci)

# joined data frame for PC llinear regressions

pat_pcalm <- masterpat2[c(1,2,5,6,13)]

pat_pcalm <- cbind(pat_pcalm, pat.pci) #Both data sets have 467 observations
```

The functions `prcomp` and `princomp` are both possible to use for this analysis. The `prcomp` stores the "scores" as `x`, while `princomp` stores them as `scores`. Useful to know when extracting the data from it for linear regressions. The function `princomp` uses Eigen decomposition of the covariance and correlations between samples. The `prcomp` uses the singular value decomposition between variables.

#### Pathogen \~ PC1 & PC2

```{r, Ant PC1-2}
# Formatting formula for p value
# Formatting formula for p value
format.p <- function(p, precision = 0.001) {
  digits <- -log(precision, base = 10)
  p <- formatC(p, format = 'f', digits = digits)
  if (p < 0.001) {
    p = paste0('< ', precision)}
  if (p >= 0.001) {
    p = paste0('= ', p)    }
  sub("0", "0", p)
}

plmpc1 <- lm(Pathogen_percent_damage ~ PC1, data = pat_pcalm)

# PC1
# Formatted p-value
pathogen_p1 <- cor.test(pat_pcalm$Pathogen_percent_damage, pat_pcalm$PC1)$p.value

pathogen_p1 = format.p(pathogen_p1) # This is just to make the p-value nicer. 

## Plot PC1
       
pat_pc1 <- ggplot(pat_pcalm, aes(PC1, Pathogen_percent_damage)) +
  geom_jitter(aes(color = Species, shape = E_load), size = 3, alpha = 0.6) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.75) +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 7,
                        aes(label = paste(..eq.label.., sprintf("italic('p')~'%s'", pathogen_p1), 
                                          sep = "~~~~"))) +
  scale_color_manual(labels=c("A. membranacea", 
                              "C. cainito",
                              "C. alliodora", 
                              "Dypterix .sp", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme_minimal(base_size = 16) +
  labs(y = "Pathogen damage (%)", caption = "") +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")

pat_pc1

#ggsave(filename="./figures/Aim3_PatPC1_AUG282023.png", plot = pat_pc1, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")


# PC2
# Formatted p-values
pathogen_p2 <- cor.test(pat_pcalm$Pathogen_percent_damage, pat_pcalm$PC2)$p.value

pathogen_p2 =format.p(pathogen_p2) # This is just to make the p-value nicer. 

## Plot PC2
plmpc2 <- lm(Pathogen_percent_damage ~ PC2, data = pat_pcalm)

pat_pc2 <- ggplot(pat_pcalm, aes(PC2, Pathogen_percent_damage)) +
  geom_jitter(aes(color = Species, shape = E_load), size = 3, alpha = 0.6) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.75) +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 7,
                        aes(label = paste(..eq.label.., sprintf("italic('p')~'%s'", pathogen_p2), 
                                          sep = "~~~~"))) +
  scale_color_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora",
                              "Dypterix .sp",
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme_minimal(base_size = 16) +
  labs(y = "Pathogen damage (%)", caption = "") +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
  
  
#pat_pc2

#ggsave(filename="./figures/Aim3_PatPC2_AUG282023.png", plot = pat_pc2, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```

### Fig 5
Ant and Pathogen PC-LMs Grid plot

```{r, Ant & Pathogen PC1-2}
figure3<- ggarrange(ant_pc1, ant_pc2, pat_pc1, pat_pc2,
                    nrow = 2, 
                    ncol=2, 
                    label.x = -0.015, vjust = 1, 
                    labels = c("(a)", "(b)", "(c)", "(d)"),
                    common.legend = TRUE, 
                    legend="bottom")

figure3
# Adding caption
# ant_caption <- expression("*All individual leaves per individual per tree species included ("~ italic("n") ~ "= 210).")
# ant_pca_with_caption <- annotate_figure(antpca_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)

#ant_pca_with_caption

#ggsave(filename = "./figures/Aim3_Fig3_04JAN2024.png", plot = figure3, dpi=600, units=c("mm"), width = 300, height = 225, bg = "white")
#Previously named Aim3_AntPCS_SEPT252023.png
```


# Phyloseq:

## Statistical analyses and data visualization with Phyloseq

The `phyloseq` package allows me to perform most of the necessary analyses with just a couple of phyloseq objects (e.g. data frames, relative abundance calculations, etc.). Previous data frames created are still needed for further analyses (e.g. dbRDA and PSLR). There are some difficulties with manipulating the data with `phyloseq`. When merging objects the categorical factors are coerced to numeric, hence losing that information. See [here](https://github.com/joey711/phyloseq/issues/465) and comments in code chunks.

## Phyloseq: plots and graphs

```{r, Phyloseq plots and graphs}
# Abundance plots
# Plots use data without singletons and trimmed for greenhouse endophytes.
# EndoAbun <- speedyseq::plot_bar(newpq1, "Species", "Abundance", "class") +
#   scale_fill_manual(values = met.brewer(name="Redon", n=11, type="continuous")) +
#   labs(title = "Ascomycota endophyte abundance(cleaned)" ) +
#   facet_wrap(~E_load)
# EndoAbun
#ggsave(filename="Aim3_AbunBarPlot_06272022.jpeg", plot = EndoAbun, dpi=600, units=c("mm"), width=200, height=200)
#
# Agglomerate taxa and merging data to make plot ####
# Similar to Relative abundance calculate in code above
# 
#View(sample_data(newpq1))
# 
#make a new phyloseq object that groups all taxa by class
# ps3 <- tax_glom(newpq1, "class") 
#make it relative
# ps0 <- transform_sample_counts(ps3, function(x) x / sum(x))
#merge samples so that they are all grouped/binned by species
# ps1 <- merge_samples(ps0, "Species")
# repair factors
# sample_data(ps1)$Species <- levels(sample_data(ps0)$Species)[get_variable(ps1, "Species")]
# 
#make relative again.
# ps4 <- transform_sample_counts(ps1, function(x) x / sum(x))
# 
# rel_abundplot <- plot_bar(ps4, "Species", "Abundance") + geom_bar(aes(fill=class), stat="identity", position="stack")+
#   labs(x = "Species", y = "Relative abundance (%)", fill="Class") +
#    scale_fill_manual(values = met.brewer(name = "Signac", type="discrete"))
# rel_abundplot
# 
# 
######
# 
# speedyseq::plot_bar(newpq1, "Species", "Abundance", "order") +
#   facet_grid(~E_load)
# 
# speedyseq::plot_bar(newpq1, "class", "Abundance", "class") +
# facet_grid(Species~.)
# 
#plot_tree(taxglom, color = "Species", shape = "class", size = "abundance")
# 
# Cladogram ####
#plot_tree(newpq1, color="Species", label.tips="taxa_names", ladderize="left", plot.margin=0.3)
# 
# Heatmap ####
# 
#plot_heatmap(newpqRA, sample.label = "Species", taxa.label="class")


```

## Phyloseq: Richness

Plots with `phyloseq` package.

```{r}
# Richness ####
# Theme set
theme_set(theme_bw())
pal = "Set1"
scale_colour_discrete <-  function(palname=pal, ...){
  scale_colour_brewer(palette=palname, ...)
}
scale_fill_discrete <-  function(palname=pal, ...){
  scale_fill_brewer(palette=palname, ...)
}

# General plot with singletons

p <- plot_richness(newpq1, "Species", color = "Species",measures = c("Observed", "Shannon"), scales="free") +
  scale_color_manual(aes(color = "Species"),values = met.brewer(name="Redon", n=11, type="discrete")) +
  geom_point(size=2, alpha=0.7, position = "jitter") +
  geom_boxplot(alpha=0.7)+ 
  labs(title = "Ascomycota endophyte observed richness and Shannon Diversity" ) +
  theme(legend.position="none", axis.text.x=element_text(angle=45,hjust=1,vjust=1,size=12))
p$layers <- p$layers[-1]
p
#ggsave(filename = "Aim3_AlphaDiversity_06272022.jpeg", plot = p, dpi=600, units=c("mm"), width=200, height=200)


# Repair variables that were damaged during merge (coerced to numeric)
# See: https://github.com/joey711/phyloseq/issues/465
#Species
#replicates <- sample_data(mergedpq)$Species |> 
 # sort()|>
 # table()|>
 # as.data.frame # you can use as_tibble(), but then you must use replicates$n in next line
#otu_table(mergedpq) <- otu_table(mergedpq)/replicates$Freq

#newmetdat <- sample_data(newpq) |>
#  as_tibble() |>
#  distinct(Species, .keep_all = TRUE) |> 
 # arrange(Species) |>
 # as.data.frame()
#rownames(newmetdat) <- rownames(otu_table(mergedpq))
#sample_data(mergedpq) <- newmetdat
```

## Phyloseq: Ordination and Distance matrices

The main purpose is to understand community similarity across trials and time points.This answers the general questions" 1) Did trials differ from each other? 2) Did time play a part in the community composition differences we see) -June/July 2023

```{r}
# Just OTUs, without singletons
r <- ordinate(newpq1, "NMDS", "bray")

# NMDS by Trial_Code (Trial_Code = trial replicate)
p1 <- plot_ordination(newpq1, r, type = "samples", color = "Trial_Code", title = "Community Composition by Trial Code") +
  stat_ellipse(geom = "polygon", aes(fill = Trial_Code), alpha = 0.25, level = 0.95) +
 labs(caption = "Trials for ant and pathogen data sets go from T1-T5. Repeated surveys for ant data set are > T6") +
  facet_wrap(~Species)
p1 

#ggsave(filename ="./figures/Aim3_NMDS_06022023_TrialCode.jpeg" , plot = p1, dpi=600, units=c("mm"), width=200, height=200)

# NMDS by Trial_type (an trial or pathogen trial)
p2 <- plot_ordination(newpq1, r, type = "samples", color = "Trial_type", title = "Community Composition by Trial type") +
  stat_ellipse(geom = "polygon", aes(fill = Trial_type), alpha = 0.25, level = 0.95) +
 labs(caption = "Commmunity composition for ant and pathogen data sets. For the most part, plants used for trials were inoculated at the same time per species and trialed and preserved within 5-6 days of final day of inoculation") +
  facet_wrap(~Species)
p2

#ggsave(filename ="./figures/Aim3_NMDS_06022023_TrialType.jpeg" , plot = p2, dpi=600, units=c("mm"), width=200, height=200)

# Samples 
p3 <- plot_ordination(newpq1, r, type="samples", color="Species")
p3 + geom_point(size = 3) +
  ggtitle("Tree Species")
  #facet_wrap(~E_load)
#geom_polygon(aes(fill=Species), alpha = 0.5) +
p3

# biplot
# p3 = plot_ordination(newpq, r, type="biplot", color="class", shape="class", title="biplot")
# p3
# 
# Split
# p4 = plot_ordination(newpq, r, type="split", color="class", title="split", label="Species") 
# p4
```

After meddling with this for a little bit, I do not like how this plots my data. I find it confusing to edit and know what it is plotting exactly. I will plot these ordinations by using the data frames cleaned and trimmed with phyloseq. -BAR 06/19/2022 *The main ordination plot is the one produces in the dbRDA section. These ordination are good for supplementary material information* -BAR 7/04/2023

# FEF Community Analysis


## Distance-based redundancy analyses (dbRDA)

Code written by Mareli Sánchez Juliá. Modified by Bolívar Aponte Rolón- March 2022 Partial dbRDA was eliminated. Due to my experimental set up, performing a partial dbRDA does not make much sense. This is useful when looking at change over time in a categorical manner (e.g. sampling every two weeks). My data set does not test for anything similar.

An explanation of why we use dbRDA with oout type of data from Perter Tellez's 2022 paper: *"We used distance-based redundancy analyses (dbRDA) to visualize associations between leaf functional traits and endophyte communities. We excluded OTUs represented by a single sequence (singletons) and calculated a Bray-Curtis dissimilarity matrix based on endophyte relative abundance data".* *We tested for differences in endophyte community composition as a function of host species and genus, using a permutational multivariate analysis of variance (PERMANOVA, 999 permutations, (69)). We used a permutational analysis of multivariate dispersion (PERMDISP; (69)) to test for homogeneity of variance in endophyte communities. We used a PERMDISP as a companion to PERMANOVA to exclude the possibility that any significant differences were caused by differences in the variance of endophyte communities. The relative explanatory power of host species and leaf functional traits on endophyte communities was compared using a partial-dbRDA.*

Results from dbRDA (`capscale`) have not been compared to PERMANOVA (`adonis2`) yet. - 11/21/22. Results should be the same or very similar.

### Making a distance matrix

```{r, Distance Matrix}
otu_e.dist <- vegdist(t(rabun), method="bray", binary=FALSE)
#Using "rabun". No singletons
#Bray-Curtis dissimilarity matrix
```

### Leaf trait selection

#### Choosing traits for dbRDA model
The `capscale` and `dbrda` function are very similar [see here](https://uw.pressbooks.pub/appliedmultivariatestatistics/chapter/rda-and-dbrda/#distance-based%20ReDundancy%20Analysis%20(dbRDA)). 
```{r}
# Model with intercept only ####
m0 <- dbrda(otu_e.dist ~ 1, data = ndata2, na.action = na.omit) #Model with intercept only.
m0
m1 <- dbrda(otu_e.dist ~ ., data = ndata2, na.action = na.omit) # Model with all explanatory variables.
m1

# Model with species, eload and leaf traits. ####
m2<- dbrda(otu_e.dist ~ Species + E_load + Anthocyanins + Thickness + Toughness + LMA, data = ndata2, na.action = na.omit)
m2

#Assessing marginal significance of constraining variables 
#anova(m2, by = "margin") # test for sign. environ. variables
#anova(m2, by = "axis")# test axes for significance
#anova(m2, by="axis", perm.max=500)#tests for sign. variables, but adds them sequentially.

# Model with just traits ####
# No species, Trial_type and E_load
m3 <- dbrda(otu_e.dist ~ Anthocyanins + Thickness + Toughness + LMA, data = ndata2, na.action = na.omit)

#Assessing marginal significance of constraining variables 
anova(m3, by = "margin")
anova(m3, by = "term")
anova(m3, by="axis", perm.max=500) 
```

### Forward and backward selection with `ordistep` - just leaf traits
 
 I used m2 as the "scope" because it does not contain Trial_type and Trial_Code. This is a factor that is only relevant for the details of the herbivory and pathogen assays. Differences detected between the trial types and trial_code are not important or unrealistic for the question at hand. 

```{r}
#Both, forward and backward selection. This way I can see the step by step.
#Selection starting from m2 model
dbrda_selection <- ordistep(m0, scope = formula(m2), Pin = 0.5, Pout =0.05 ,trace = T, permutations = how(nperm = 999), steps = 50, direction = "forward")

summary(dbrda_selection)
plot(dbrda_selection)
dbrda_selection$anova

#Assessing marginal significance of constraining variables 
#anova(dbrda_selection, by = "margin") # test for sign. environ. variables 
#anova(dbrda_selection, by = "axis") # test axes for significance
#anova(dbrda_selection, by="axis", perm.max=500) #tests for sign. variables, but adds them sequentially.

#Selection stating from m3 model
#Taking Species and E_load out. Again not relevant. What I want to know is the influence the leaf traits have on the fungal community. 
m3_dbrda_selection <- ordistep(m0, scope = formula(m3), Pin = 0.5, Pout =0.05 ,trace = T, permutations = how(nperm = 999), steps = 50, direction = "forward")
summary(m3_dbrda_selection)

#Assessing marginal significance of constraining variables 
anova(m3_dbrda_selection, by = "margin")
anova(m3_dbrda_selection, by = "term")
anova(m3_dbrda_selection, by="axis", perm.max=500) 

## Model 3 and 5 keep species and trial type as the most significant explanatory variables. Yes, the community composition will be different across species due to the combinantion of species traits and leaf functional trait values. 
```

## Figure 3

```{r, m3 dbRDA}
 
#dbRDa with `dbrda` function. it can be calculated with `capscale` function too. VERY similar.
#Best model selected with `ordistep` function 
#Terms: otu_e.dist ~ Thickness + Toughness + Anthocyanins + LMA
m3dbRDA <- dbrda(otu_e.dist ~ Anthocyanins + Toughness + Thickness + LMA, data= ndata2, dist="bray", na.action = na.omit)
anova.cca(m3dbRDA, by="margin")
m3dbrda_summary <- summary(m3dbRDA)
plot(m3dbRDA)
#Correlation of constrained and unconstrained axes
cor(m3dbrda_summary$constraints) |>
  round(2)

#Plotting dbRDA  with color by continous leaf lifespan
#plot using ggplot2
names(m3dbRDA)
B <- summary(m3dbRDA)

A.1 <- vegan::scores(m3dbRDA)
A.2 <- A.1$sites
A.3 <- cbind(A.2, ndata2)

#scores for arrows
A.4 <- data.frame(vegan::scores(m3dbRDA, display = "bp"))

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = (dbRDA1*2), yend = (dbRDA2*2), x = 0, y = 0, shape = NULL, color = NULL, fill = NULL)
label_map <- aes(x = 2*dbRDA1, y = 2*dbRDA2, label = row.names(A.4), shape = NULL, color = NULL, fill = NULL)
arrowhead = arrow(length = unit(0.02, "npc"))

#subset A4 for labeling
A.4 <- A.4[sort(rownames(A.4)),]

A4.sub1 <- A.4[3,] #Thickness
A4.sub2 <- A.4[1,] #Anthocyanins
A4.sub3 <- A.4[2,] #LMA
A4.sub4 <- A.4[4,] #Toughness

#A4.sub4

# Make plot
p_m3 <- ggplot(data = A.3, aes(x = dbRDA1, y = dbRDA2))
p_m3dbrda <- p_m3 +
  geom_point(data = A.3, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.8, stroke = 1) +
  geom_segment(arrow_map, size = rel(.8), data = A.4, color = "black", arrow = arrowhead) +
  geom_vline(xintercept = 0, color = "grey30", linetype = "dashed") + # plot vertical line
  geom_hline(yintercept = 0, color = "grey30", linetype = "dashed") + # plot horizontal line
  geom_text(label_map, size = rel(4), data = A4.sub1, fontface = "bold", show.legend = FALSE, hjust = 1, label = c("LT"), nudge_y = -0.15) +
  geom_text(label_map, size = rel(4), data = A4.sub2, fontface = "bold", show.legend = FALSE, hjust = 0.2, label = c("ACI"), nudge_y = -0.2) +
  geom_text(label_map, size = rel(4), data = A4.sub3, fontface = "bold", show.legend = FALSE, hjust = 1.2, label = c("LMA"), nudge_y = -0.05) +
  geom_text(label_map, size = rel(4), data = A4.sub4, fontface = "bold", show.legend = FALSE, hjust = 1.2, label = c("LPS"), nudge_y = 0.05) +
  xlab(label = paste("dbRDA1 (", round(B$concont$importance[2,1]*100, digits = 1), "%)", sep="")) +
  ylab(label = paste("dbRDA2 (", round(B$concont$importance[2,2]*100, digits = 1), "%)", sep="")) +
  scale_color_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  scale_shape_manual(name = "Treatment", labels = c("E-", "E+"), values = c(16, 17)) +
  stat_ellipse(aes(color=Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
  #labs(caption = "ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness")+
  theme_classic(base_size = 12) +
  theme(plot.title = element_text(color="black", size = 12, face="bold"),
        legend.title = element_text(face = "bold"),
        legend.text = element_text(color="black", size = 12, face="italic"))
# Rearranging the order of layers so arrows are above the points.
p_m3dbrda$layers
p_m3dbrda$layers <- c(p_m3dbrda$layers, p_m3dbrda$layers[[2]], p_m3dbrda$layers[[5]], p_m3dbrda$layers[[6]], p_m3dbrda$layers[[7]], p_m3dbrda$layers[[8]])
p_m3dbrda

#ggsave(filename="./figures/Aim3_m3dbRDA_12JAN2024.svg", plot=p_m3dbrda, dpi=600, units=c("mm"), width=300, height=300)
```

# NMDS: Non-Metric Multidimensional Scaling

A brief explanation on the use of NMDS to interpret our projects: *We used LMA, LDMC, leaf punch strength, leaf thickness, %C, and %N as the constraining variables. Next, we used PERMANOVA marginal tests to assess the amount of variation explained by each leaf trait. We used Non-metric Multidimensional Scaling (NMDS) to visualize patterns in endophyte communities among host taxa.* -Peter tellez (2022)

```{r, NMDS}
#Ordination - NMDS with bray-curtis #########
x <- as.matrix(otu_e.dist)

# Choosing the number of dimensions
NMDS.scree <- function(x) { #where x is the name of the data frame variable
  plot(rep(1, 10), replicate(10, metaMDS(x, autotransform = F, k = 1)$stress), xlim = c(1, 10),ylim = c(0, 0.30), xlab = "# of Dimensions", ylab = "Stress", main = "NMDS stress plot")
  for (i in 1:10) {
    points(rep(i + 1,10),replicate(10, metaMDS(x, autotransform = F, k = i + 1)$stress))
  }
}

#NMDS.scree(x) #4 dimension seem to be appropriate to keep the stress around 0.15. More dimension will complicate the interpretation of results.

NMDS <- metaMDS(x,
                distance = "bray",
                display = c("sites", "species"),
                noshare = TRUE,
                autotransform = FALSE,
                wascores = TRUE,
                tidy = TRUE,
                k = 4,trymax = 500)
stressplot(NMDS)
##NMDS does not have the "species" or "site" scores for some reason. This worked up until Oct 6, 2022.

#Adding site scores to `NMDS`
sppscores(NMDS) <- t(rabun) # `rabun` if the dataframe with raw relative abundance of OTU's. It does not contain Ascomycota singletons (total = 569 OTUs).

data.scores <- as_tibble(vegan::scores(NMDS)$sites)#Using the scores function from vegan to extract the site scores and convert to df for ggplot use.
# Solution found here: https://stackoverflow.com/questions/71941069/species-scores-not-available-as-result-of-metamds

# NMDS Aesthetics ####

NM.DS <- ggplot(data.scores, aes(NMDS1, NMDS2, color = ndata2$Species)) +
  geom_point(data = data.scores, aes(shape= ndata2$Trial_type),size = 3, alpha = 0.5, stroke = 1) +
  scale_shape_manual(values=c(15:22)) +
  # scale_color_manual(values = met.brewer(name = "Nizami", n = 8, type="discrete")) +
  geom_hline(yintercept = 0, colour = "grey50", size = 0.65) +
  geom_vline(xintercept = 0, colour = "grey50", size = 0.65) +
  theme_bw(base_size = 12) +
  theme(legend.position="right", legend.title = element_text(),
        legend.text = element_text(face = "italic")) +
  stat_ellipse(mapping = NULL, data = data.scores, geom = "path", size = 1.3,
position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51,
na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) 

NM.DS
#ggsave(filename ="Aim3_NMDS_06272022.jpeg" , plot = NM.DS, dpi=600, units=c("mm"), width=200, height=200)
#
#
```



## PERMDISP

```{r}
#Corroborating what dbRDA results tell us
#By Tree Species
beta_disp <-
  betadisper(as.dist(otu_e.dist),
             ndata2$Species,
             # Grouping variable
             type = "median",
             sqrt.dist = FALSE)

anova(beta_disp)
TukeyHSD(beta_disp, conf.level = 0.95)

set.seed(123)
beta_perm1 <-
  permutest(beta_disp,
            parallel = 8,
            permutations = 999,
            by = "margin")

beta_perm1 #Communities inside tree species do not differ in dispersion

TukeyHSD(beta_disp, conf.level = 0.95)

# By treatment group
beta_disp2  <-
  betadisper(otu_e.dist,
             ndata2$E_load,
             type = "median",
             sqrt.dist = FALSE)
anova(beta_disp2) # Significant differences in community according to E_load


set.seed(123)
beta_perm2 <-
  permutest(beta_disp2,
            parallel = 8,
            permutations = 999,
            by = "margin")
beta_perm2 # We see differences in dispersion of E_load
TukeyHSD(beta_disp2, conf.level = 0.95)

```
## ANOSIM

```{r}
# ANOSIM ####
# Tests if differences between groups are greater than within groups. 
otu.anosim <- anosim(otu_e.dist, ndata2$Species, permutations = 999, distance = "bray", strata = NULL)
summary(otu.anosim)
plot(otu.anosim) 
```


# GLLMs: How do leaf traits influence herbivory and pathogenicity?

## Ant Linear Mixed Models: `logit_herbivory ~ raw functional leaf traits`

Now that we have answered how the leaf functional traits influence influence the effects of herbivory and pathogenicity in plants. In June 2023, we have eliminated "Shannon Diversity" as a fixed effect. We will evaluate the effects of community diversity and composition in other analyses.

```{r, Ant Simple Linear Models wit masterant2 data set}
# ANTS:Diversity
# Model with intercept only
M0 <- lm(logit_herbivory ~ 1, data = masterant2, na.action = na.exclude)
summary(M0)
AIC(M0)
plot(M0)

# M1
M1 <- lm(logit_herbivory ~ LMA + Species + Anthocyanins + Thickness + Toughness + Shannon + E_load, data = masterant2, na.action = na.exclude)

#Model with all continuous explanatory variables.
summary(M1)
AIC(M1) #737

# Transforming "Ant_percent_leafloss" with logit() and using that transformed data reduces the AIC value to ~738. It is a better fit model. The transformation of percent herbivory is due to the many values close to zero or zeros. 

# Residuals
M1_resid <- resid(M1, type = "response")
M1_fitted <- fitted(M1)
#Histograms
hist(M1_resid)
hist(M1_fitted)
# Plots
plot(M1)
plot_model(M1, type = "diag")

# Three ways to get type 3 anova. The first one requires that there are no atomic vector. The ;linear regression has to be coded in one line, not creating shorthand formula. The rest are pretty self evident. For drop1(model,.~., test = "F) we obtain the same as Anova() from the "car" package. Without the .~. we obtain terms or interactions that are not significant. 

#anova(M1,type="marginal") #What is a type III ANOVA?
Anova(M1, type = 3)
drop1(M1,test = "F", trace = TRUE)
drop1(M1, .~., test="F", trace = TRUE)

# Stepwise selection of linear model (lm())
M1AIC <- stepAIC(update(M1, .~.), direction = "both", k = 2)
M1AIC$anova
AIC(M1AIC) #586.7715 #736.86 06/04/2023 -BAR
plot(M1AIC)
plot_model(M1AIC, type = "diag")
#Final Model:
#logit_herbivory ~ LMA + Species + Thickness + Shannon + E_load
```

Using "masterant2" improves normality of residuals and overall model. 5/23/2023

Species has a high VIF. This should change when I use species as a random effect. The residuals spread increases slightly as the fitted values increase. Indicating heterogeneity. Note that some nests have residuals that are above or below the zero line, indicating the need for a random effect. Possibly Species and E_Load. Shannon diversity index does not seem to have a significant effect on herbivory.

The final model as a results of `stepAIC()` is: `logit_herbivory ~ LMA + Species + Thickness + Shannon + E_load`

## Random effect models with fixed terms

### ANTS: Leaf traits and Herbivory

Models for predicting herbivory loss using FEF community diversity. Use of raw functional leaf trait values.

-   I opted to remove Anthocyanins and Toughness due to high colinearity with LMA (see Correlations section). ML: fixed terms
-   Using results from stepAIC() as the starting point.
-   Using Maximum Likelihood (ML) to model.

```{r, Ant masterant2 ML model selection}
#ANTS: Species as random effect, NO interactions
#M2
M2 <- lme(logit_herbivory ~ Thickness + LMA + E_load + Shannon, random = ~1 | Species, method = "ML", data = masterant2, na.action = na.exclude)
summary(M2) #Adding the random effect INCREASES AIC score.
AIC(M2)# 755 as of 30JAN2024

# Residuals histograms and plots ####
M2_resid <- resid(M2, type = "response")
M2_fitted <- fitted(M2)
hist(M2_resid)
hist(M2_fitted)
plot(M2) 
plot_model(M2, type = "diag") # The residuals spread increases slightly as the fitted values increase. Indicating heterogeneity.

# Stepwise selection of terms
M2.step <- stepAIC(update(M2, .~.), direction = "both", k= 2)
M2.step$anova
AIC(M2.step) #Step:  No change in AIC score. 30JAN2024

# ANOVAs
Anova(M2.step, type = 3)
drop1(M2.step, .~., test="Chisq", trace = TRUE)

# M3 ####
# Nesting Species and E_load
M3 <- lme(logit_herbivory ~ Thickness + LMA + Shannon, random = ~1 | Species/E_load, method = "ML", data = masterant2, na.action = na.exclude)
summary(M3) #Nestin E_load in Species term INCREASES AIC score.
AIC(M3) #765 as of 30JAN2024

# Residuals histograms and plots ####
M3_resid <- resid(M3, type = "response")
M3_fitted <- fitted(M3)
hist(M3_resid)
hist(M3_fitted)
plot(M3)
plot_model(M3, type = "diag")
```

-   Nesting E_load in Species INCREASES the AIC score.

-   Model M1 (lm(y\~a+b+c+d)) remains as the model with the lowest AIC value.

## Random effect models with interactions

### ML: interactions

```{r, Ant RAW ML interactions}
# M4: modelling interactions_ No E_load.x, Total_reads and Observed richness #### 
# Using the fixed terms from M1 model.
M4 <- lme(logit_herbivory ~ Thickness  * LMA  * E_load * Shannon, random = ~1|Species, method = "ML", data = masterant2, na.action = na.exclude) #Observed richness is confounded by Shannon diversity, probably. The same happens with Toughness and Thickness. 
summary(M4)
AIC(M4) #748 as of 30JAN2024

M4.step <- stepAIC(update(M4, .~.) , direction = "both", k= 2)
M4.step$anova

# Final Model:
# logit_herbivory ~ Thickness + LMA + E_load + Shannon + Thickness:LMA + 
#     LMA:E_load + LMA:Shannon + E_load:Shannon + LMA:E_load:Shannon

# Residuals histograms and plots
M4_resid <- resid(M4, type = "response")
M4_fitted <- fitted(M4)
hist(M4_resid)
hist(M4_fitted)
plot(M4)
plot_model(M4.step, type = "diag")
```

-   Not the best models

### REML: interactions

Using Restricted Maximum Likelihood (REML) to model. Maximum likelihood tends to be biased with high dimensional data. No interactions yet, checking random effects.

```{r, Ant masternat2 RAW REML model selection}
# REML
#M1REM All fixed terms
M1REM <- lme(logit_herbivory ~ Anthocyanins + Toughness + Thickness  + LMA + E_load + Shannon, random = ~1 | Species, method = "REML", data = masterant2, na.action = na.exclude)
summary(M1REM)
Anova(M1REM, type = 3)
AIC(M1REM) # 757 as of 30JAN2024 it increases the AIC score.

M1.gls <- gls(logit_herbivory ~ Anthocyanins + Toughness + Thickness  + LMA + E_load + Shannon, method = "REML", data = masterant2, na.action = na.exclude)
summary(M1.gls)
Anova(M1REM, type = 3)
AIC(M1.gls) #801 as of 30JAN2024
```

-   Random effect "Species" REDUCES the AIC score. It is important to incorporate as a random effect in the model!

### REML: Variance Structure

Using `varIdent()` to model variance structure.

-   Model M2REM without Anthocyanins and Toughness has the lowest AIC score.
-   Removing Shannon diversity. In previous models it has been a trondg predictor of herbivory.

```{r}
# M2REM: Removed Toughness from M1REM
M2REM <- lme(logit_herbivory ~ Thickness  + LMA + E_load, random = ~1 | Species, method = "REML", data = masterant2, na.action = na.exclude) #

#Validation
plot(M2REM)
summary(M2REM)
Anova(M2REM, type = 3)
AIC(M2REM) #594.0651 # 1934.192 as of 5/23/23 # 752.4332 as of 30/OCT/2023
```

-   The spread of residuals vs. fitted values improves so does AIC value.


Maybe there is some variance structure...

```{r}
#Optimizers
ctrl <- lmeControl(opt='optim')
ctrl2 <- lmeControl(opt = "nlminb")

#M3REM: Same fixed terms as M2REM
M3REM <- lme(logit_herbivory ~ Thickness  + LMA + E_load, weights = varIdent(form = ~ 1|Species),  random = ~ 1 | Species, method = "REML", control = ctrl, data = masterant2, na.action = na.exclude)

plot(M3REM)
summary(M3REM)
Anova(M3REM, type = 3)
AIC(M3REM)  #741.7825 as of 30/OCT/2023
```

The spread of residuals vs. fitted values improves for M2REM and so does AIC value. Model M3REM has the lowest AIC value and the spread of residuals vs fitted values is more constant/even throughout, regardless of optimizer used (AIC = 741.7852).

There are still signs of heteroskedasticity, but better. There is variance structure at the species levels. Among the REML models M3REM is the best fit.

Let's continue.

```{r}
# M4REM: Same terms as M3REM, but nesting E-load in Species
M4REM <- lme(logit_herbivory ~ Thickness  + LMA,  weights = varIdent(form = ~ 1|Species),  random = ~ 1 | Species/E_load, method = "REML", control = ctrl, data = masterant2, na.action = na.exclude)

# Validation
plot(M4REM)
summary(M4REM)
Anova(M4REM, type = 3)
AIC(M4REM) # 753 as of 01/NOV/2023
plot_model(M4REM, type = "diag")
```

-   Worst than M3REM.

-   Nesting E-load in Species does not improve the model.

Let's finally model with interactions.

```{r}
#M5_INTERACTIONS

M5REM <- lme(logit_herbivory ~ Thickness  * LMA * E_load, weights = varIdent(form = ~ 1|Species),  random = ~ 1 | Species, method = "REML", control = ctrl, data = masterant2, na.action = na.exclude)

#Validation
plot(M5REM)
summary(M5REM)
AIC(M5REM) # 527 AIC # 1571.156 as of 5/23/23 # 720.7501 as of 30/OCT/2023

plot(M5REM)

logit_est <- plot_model(M5REM, type = "diag")
logit_est
tab_model(M5REM, M3REM,
          show.aic = TRUE, 
          show.intercept = TRUE, 
          show.df = TRUE)

#ggsave(filename = "./figures/Aim3_Ant_estimates_GLM_30OCT2023.jpg", plot = logit_est, dpi = 600, units = "mm", width = 150, height = 180)

#Model comparison and selection
MuMIn::model.sel(M1REM, M2REM, M3REM, M4REM, M5REM)[, c("df", "logLik", "AICc", "delta")]
```

#### Notes on Manual model selection

From the previous section I can see that model `M3REM` and `M5REM` have the lowest AIC scores. This is achieved by modeling interaction of the explanatory variables. Yet some interactions do not seem to be significant. What is the most parsimonious model I can achieve?

This doesn't make much sense to me. Sure E_load reduces the AIC score but of course it is going to have an impact or predict well herbivory loss. It is a treatment, not a continuous explanatory variable. It just does not fit the question well.

The best fit model(s), considering the elimination of Anthocyanins and Toughness due to high colinearity, is `M5REM` (AIC 720) and `M3REM` (AIC 741). All models had Shannon diversity removed as it was not a significant predictor of herbivory.

### Conclusions of model selection using REML model estimation (ANT)

The model `M5REM` is the best fit model with random effect (Species). We are trying to understand how FEF diversity influences herbivory on an per species/plant basis. The variance structure seems to not be nested. Nesting it increases AIC score. Hence, no need to nest Species/E_load.

## Figure S7

## Ants: Simple linear regression plots

```{r, ggplot Magic}
par(mfrow = c(1, 1))
wes_paleta2 <- wes_palette(name = "Darjeeling1", 2, type = "continuous")

#Boxplot
hbox <-  ggplot(data = masterant2, aes(x = Species, y = Ant_percent_leafloss), color = Species) +
  geom_boxplot(aes(fill = E_load),outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.7) +
  scale_fill_manual(values = wes_paleta2)+
  geom_jitter(color="grey20", size = 2, alpha= 0.5) +
  theme_minimal(base_size = 12) +
  theme(legend.position="right", 
         legend.title = element_blank(),
         legend.text = element_text(size = 16),
         axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x="", y="Leaf Herbivory (%)", caption = "*All replicate leaves from tree species included  (n = 210)") +
  annotate("text", x = 2.5, y = .65, label = "")
  # stat_compare_means(comparisons = mycomparisons ) +
  # stat_compare_means(method = "kruskal.test", label = "p.signif")
hbox

# Ant
# Regressions

# Herbivory and Toughness
summary(lm(logit_herbivory ~ Toughness, data = masterant2))
 
herb_lps <- ggplot(data = masterant2, aes(y= logit_herbivory, x = Toughness, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x=expression(paste("Leaf punch strength (N mm","^-1)")), y = "logit[Herbivory (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))  +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
herb_lps

# fit <- lm(logit_herbivory ~ Thickness, data = masterant2)
# 
# rSquared <- summary(fit)$r.squared
# rSquared
# anova(fit)
# pVal <- anova(fit)$'Pr(>F)'[1]
# pVal

# Herbivory and Anthocyanins
summary(lm(logit_herbivory ~ Anthocyanins, data = masterant2))

herb_aci <- ggplot(data = masterant2, aes(y= logit_herbivory, x = Anthocyanins, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x=expression(paste("ACI (% ", italic("A") [lambda]," at 931 nm / % ", italic("A") [lambda]," at 530 nm)")), y = "logit[Herbivory (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))  +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
herb_aci
#scale_shape_manual(values = c(1:7))

# Herbivory and leaf thickness
summary(lm(logit_herbivory ~ Thickness, data = masterant2))

herb_lt <- ggplot(data = masterant2, aes(y= logit_herbivory, x = Thickness, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x=expression(paste("Leaf thickness (",mu,"m)")), y = "logit[Herbivory (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))  +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend

herb_lt

# Herbivory and LMA
summary(lm(logit_herbivory ~ LMA, data = masterant2))

herb_lma <- ggplot(data = masterant2, aes(y= logit_herbivory, x = LMA, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x= expression(paste("LMA (mg ",mm^-2, ")")), y = "logit[Herbivory (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) 
herb_lma

# Herbivory and FEF Shannon Diversity
summary(lm(logit_herbivory ~ Shannon, data = masterant2))

# Extracting effect size of model to plot
herb_shannon <- ggplot(data = masterant2, aes(y= logit_herbivory, x = Shannon, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x= "Shannon's Diversity Index", y = "logit[Herbivory (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) 
 



 # Multiples plots together

ant_arranged <- ggarrange(herb_lt, herb_lps, herb_aci, herb_lma, herb_shannon, 
                          nrow = 2, 
                          ncol=3, 
                          common.legend = TRUE, 
                          labels = c("(a)", "(b)", "(c)", "(d)", "(e)"),
                          legend="bottom")

ant_arranged

# Adding caption
# ant_caption <- "*All individuals per tree species included (n = 210)"
# ant_arranged_with_caption <- annotate_figure(ant_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)
# 
# ant_arranged_with_caption

#ggsave(filename = "./figures/Aim3_FigS7_21JAN024.jpg", plot = ant_arranged_with_caption, dpi=600, units=c("mm"), width=180, height=140, bg = "white")

```

# Pathogen Damage Analyses

## Descriptive statistics

Refer to the ANTS section for descriptive statistics and non-normality of predictor(independent variables).

```{r}
# Evaluating non-normality of the data ####
#Do not use "master" data set to assess the assumption of normality. It includes duplicate information for the explanatory variables. Meaning a sample and its data are paired multiples times with the OTU's that are present in it. Use either "data" or "newdata".

#Proceeding with exploring normality assumptions with "data" and "masterant". It retaines the mean values for all leaf replicates.

# QQPlots ####
#How it should look like
#qqPlot(rnorm(n = length(data$Anthocyanins..aci.), 
             #mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
             #sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))
             
#How it actually looks
#Using "data" set
qqPlot(data$Anthocyanins..aci.)
qqPlot(data$Thickness..micro.m.)
qqPlot(data$Toughness..lbf.)
qqPlot(data$LMA_dw)

# 
# masterpat$Prop_area_loss <- masterpat$Pathogen_area_loss/100
# 
# qqPlot(masterpat$Prop_area_loss)

# QQPlots Using "masterpat"

qqPlot(masterpat$Pathogen_Damage_area)
qqPlot(masterpat$Anthocyanins)
qqPlot(masterpat$Thickness)
qqPlot(masterpat$Toughness)
qqPlot(masterant$LMA)
qqPlot(masterant$Shannon)

#Nothing has a normal distribution. It looks like it will be necessary to use a negative binomial distribution. 

# Shapiro-Wilks tests ####
#shapiro.test(rnorm(n = length(data$Anthocyanins..aci.), 
                   #mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
                   #sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))
                   #shapiro.test(masterant$Prop_area_loss)
                   
#After seeing the non-normal distributions and the potential complications of evaluating incomplete data (i.e. NA), I decided to eliminate NA's. Refer to section "Master data" to see code for eliminating NA's. 
                 
# Using "masterant". This data set does not have NA's
hist(masterpat$Pathogen_Damage_area) #Skewed to the left
shapiro.test(masterpat$Pathogen_Damage_area) #Data deviates from the normal distribution. p-value = 7.263e-12
shapiro.test(masterpat$Anthocyanins) #Non-normal p-value = 0.0001326
shapiro.test(masterpat$Thickness) #Non-normal p-value = 7.098e-05
shapiro.test(masterpat$Toughness) #Non-normal p-value = 2.048e-09
hist(masterpat$Toughness)
shapiro.test(masterpat$LMA) #Non-normal p-value = 5.409e-06
shapiro.test(masterpat$Shannon) #Non-Normal p-value = 0.001621
hist(masterpat$Shannon)


# Pathogen_area_loss is not normally distributed. Skewed to the left.

#Conclusion from the Shapiro-Wilk tests. Some of the independent variables are not normally distributed. 

# Re-eveluating autocorrelation of terms ####

# Variance Inflation Factor on simple LM with Toughness and Thickness

vif(lm(Pathogen_Damage_area ~ Anthocyanins + Thickness + Toughness + LMA + Observed + Shannon + Total_reads + Relative_Abundance, data = masterpat))
#Variance inflation factors range from 1 upwards. The numerical value for VIF tells you (in decimal form) what percentage the variance (i.e. the standard error squared) is inflated for each coefficient. For example, a VIF of 1.9 tells you that the variance of a particular coefficient is 90% bigger than what you would expect if there was no multicollinearity — if there was no correlation with other predictors.
#A rule of thumb for interpreting the variance inflation factor:

#1 = not correlated.
#Between 1 and 5 = moderately correlated.
#Greater than 5 = highly correlated.

# All explanatory variables have a VIF that is moderately correlated.
# cor()
corr <- cor(masterpat[,c(7:16)])
corr
corrplot::corrplot(corr, type="upper", order="hclust")

#To compute the matrix of p-value, a custom R function is used :

# mat : is a matrix of data
# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(corr)
head(p.mat[, 1:4])

corrplot::corrplot(corr, method = "color", type = "upper", order = "hclust",addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45, #Text label color and rotation
         # Combine with significance
         p.mat = p.mat, sig.level = 0.05, 
         # hide correlation coefficient on the principal diagonal
         diag=FALSE
         )
```

From this autocorrelation matrix I can see that the Observed richness, Shannon diversity and Total_reads have low autocorrelation the physical leaf functional traits. These three measures of community composition are somewhat correlated. Especially the Observed species richness and the Shannon diversity index (0.719735754) and Total_reads*Shannon(-0.3244523). For this reason I am going to stick to using Shannon diversity are a community traits for predicting leaf herbivory and pathogenicity. 

LMA is highly collinear with Anthocyanins and Toughness, while it has very low correlation with Ant_percent_leafloss. I will not include Anthocyanins in the linear models. Thickness and toughness are inversely correlated with each other. Toughness seems to have a low negative correlation with Ant_percent_leafloss. I will not include it in the linear models. 

## Paired T-tests

```{r, Pathogen Assay Paired T-tests}

t.test(formula = Pathogen_Damage_area ~ E_load,
  alternative = "two.sided",
       mu = 0, 
       paired = T,   
       var.equal = TRUE,
       na.rm = FALSE,
       conf.level = 0.95, data = masterpat)
 plot(Pathogen_Damage_area ~ E_load, data = masterpat)
pat_paired <- ggplot(masterpat, aes(E_load, Pathogen_Damage_area)) +
  geom_boxplot(aes(fill = Species))
pat_paired

#ggsave(filename = "pathogen_paired.png", plot = pat_paired, dpi=600, units=c("mm"), width=300, height=300)
```

## Pathogen Linear Mixed Models: `logit_pathogenicity ~ raw functional leaf traits`

Now that we have answered how the leaf functional traits influence FEF community diversity, we can see how endophyte community diversity influences the effects of pathogenicity.

```{r}
##Pathogen
# Model with intercept only ####
P0 <- lm(logit_pathogenicity ~ 1, data = masterpat2, na.action = na.exclude)
plot(P0)
summary(P0)
AIC(P0) # 1376 as of 30JAN2024

# P1
P1 <- lm(logit_pathogenicity ~ Anthocyanins + Species + LMA + Toughness + Thickness + E_load + Shannon, data = masterpat2, na.action = na.exclude) #Model with all continuous explanatory variables.
summary(P1)
AIC(P1) # 1255.082

# Residuals
P1_resid <- resid(P1, type = "response")
P1_fitted <- fitted(P1)
#Histograms
hist(P1_resid)
hist(P1_fitted)
# Plots
plot(P1)
plot_model(P1, type = "diag")

# Stepwise selection of linear model (lm())
P1AIC <- stepAIC(update(P1, .~.), direction = "both", k = 2)
P1AIC$anova
AIC(P1AIC) #1249.769 as of 16/OCT/2023

# Three ways to get type 3 anova. The first one requires that there are no atomic vector. The ;linear regression has to be coded in one line, not creating chorthand foremula. The rest are pretty self evident. For drop1(model,.~., test = "F) we obtain the same as Anova() from the "car" package. Without the .~. we obtain terms or interactions that are not significant. 

#anova(P1,type="marginal") #What is a type III ANOVA?
Anova(P1, type = 3)
drop1(P1,test = "F", trace = TRUE)
drop1(P1, .~., test="F", trace = TRUE)
```

-   The result of `stepAIC` is `logit_pathogenicity ~  Species + Thickness + E_load`.

-   I opted to remove Anthocyanins and Toughness due to high colinearity with LMA (see Correlations section). Shannon diversity was also removed from the model.

```{r}
#P2
P2 <- lm(logit_pathogenicity ~  Species + E_load + Thickness + LMA, data = masterpat2, na.action = na.exclude)
summary(P2)
AIC(P2) #1251 as of 30JAN2024

# Residuals
P2_resid <- resid(P2, type = "response")
P2_fitted <- fitted(P2)
#Histograms
hist(P2_resid)
hist(P2_fitted)
# Plots
plot(P2)
plot_model(P2, type = "diag")


# Stepwise selection of linear model (lm())
P2AIC <- stepAIC(update(P2, .~.), direction = "both", k= 2)
P2AIC$anova
AIC(P2AIC) #1249.769 as of 30/OCT/2023
plot(P2AIC)
```

The final model from this section (P2AIC): `logit_pathogenicity ~ Species + E_load + Thickness`. LMA was removed from the model. It does not seem to be a good predictor of pathogenicity. 

## Random effect models with fixed terms

### PATHOGEN: Endophyte Diversity

### ML: fixed terms

-   Using results from stepAIC() as the starting point.
-   Using Maximum Likelihood (ML) to model.

```{r, Pathogen RAW ML model selection}
# PATHOGEN: Species as random effect, NO interactions
# P3
P3 <- lme(logit_pathogenicity ~ E_load + Thickness, random = ~1 | Species, method = "ML", data = masterpat2, na.action = na.exclude)
summary(P3) #Adding the random effect INCREASES AIC score.
AIC(P3) #1269 as of 30JAN2024

# Residuals histograms and plots
P3_resid <- resid(P3, type = "response")
P3_fitted <- fitted(P3)
hist(P3_resid)
hist(P3_fitted)
plot(P3) 
plot_model(P3, type = "diag") # The residuals spread increases slightly as the fitted values increase. Indicating heterogeneity.


# P4
# Nesting Species and E_load
P4 <- lme(logit_pathogenicity ~ Thickness, random = ~1 | Species/E_load, method = "ML", data = masterpat2, na.action = na.exclude)
summary(P4) #Removing E_load term and nesting it INCREASES AIC score.
AIC(P4) #1272 as of 30JAN2024

# Residuals histograms and plots ####
P4_resid <- resid(P4, type = "response")
P4_fitted <- fitted(P4)
hist(P4_resid)
hist(P4_fitted)
plot(P4)
plot_model(P4, type = "diag")

# Nesting E_load in Species INCREASES the AIC score.
```

There is not much improvement of P4 over P1-P2. The AIC score is higher than P1-P2. The residuals spread increases slightly as the fitted values increase. Indicating heterogeneity.

### REML: fixed terms

No interactions yet, checking random effects. \*\*Notice the use of `Treatment` as one of the fixed terms. This is a level that is not present in the Ant dataset.
I am including LMA and Treatment as fixed terms to see if they are significant. 

```{r, Restricted Maximum Likelihood (REML)}
# REML
#P1REM
P1REM <- lme(logit_pathogenicity ~ Thickness + LMA + E_load + Treatment, random = ~1 | Species, method = "REML", data = masterpat2, na.action = na.exclude)
summary(P1REM)
AIC(P1REM) # 1083.539 as of 30/OCT/2023

P1.gls <- gls(logit_pathogenicity ~ Thickness + LMA + E_load + Treatment, method = "REML", data = masterpat2, na.action = na.exclude)
summary(P1.gls)
AIC(P1.gls) #1242.096 as of 30/OCT/2023
```

Model P1REM has lowest AIC score. Random effect "Species" REDUCES the AIC score. It is important then!

## Random effect models with interactions

#### ML: interactions

```{r, Maximum Likelihood}
# P2ML: modelling interactions_ No E_load, Total_reads and Observed richness #### 
# Using the fixed terms from M1 model.
P2ML <- lme(logit_pathogenicity ~ Thickness  * LMA * Treatment * E_load, random = ~1|Species, method = "ML", data = masterpat2, na.action = na.exclude) #Observed richness is confounded by Shannon diversity, probably. The same happens with Toughness and Thickness. 
summary(P2ML)
AIC(P2ML) #1088 INCREASES AIC score.

P2.step <- stepAIC(update(P2ML, .~.) , direction = "both", k= 2)
P2.step$anova
Anova(P2.step, type = "III")
# Residuals histograms and plots
P2_resid <- resid(P2ML, type = "response")
P2_fitted <- fitted(P2ML)
hist(P2_resid)
hist(P2_fitted)
plot(P2ML)
plot_model(P2ML, type = "diag")

# Not the best models!
```

### REML: interactions

Using Restricted Maximum Likelihood (REML) to model. Maximum likelihood tends to be biased with high dimensional data. LMA is a significant predictor of pathogenicity (p \<= 0.05). 

Let's model with interactions and remove variance structure. Having Treatment and E_load as fixed effect reduces AIC score.

```{r, Pathogen RAW REML interactions}
#P3_INTERACTIONS_
P4REM <- lme(logit_pathogenicity ~  LMA * Thickness * E_load * Treatment, random = ~1 | Species, method = "REML", data = masterpat2, na.action = na.exclude)
summary(P4REM)
AIC(P4REM) #1057.048 as of 30/OCT/2023
plot(P4REM)
plot_model(P4REM, type = "diag")

# P6 Interaction between terms - nested random effects  No E_load E_load, Total_reads, and Observed Richness
P5REM <- lme(logit_pathogenicity ~  LMA * Thickness * Treatment , random = ~ 1 | Species, method = "REML", data = masterpat2, na.action = na.exclude)
summary(P5REM)
AIC(P5REM) #1071.056 as of 30/OCT/2023
plot_model(P5REM, type = "diag")
#REMOVAL OF E_LOAD INCREASES AIC SCORE.
```

## REML: Variance Structure

Maybe there is some variance structure...

```{r, Restricted  Maximum Likelihood 2}
ctrl <- lmeControl(opt='optim')

P3REM <- lme(logit_pathogenicity ~  LMA + Thickness, weights = varIdent(form = ~ 1|Species),  random = ~ 1 | Species/E_load/Treatment, method = "REML", control = ctrl, data = masterpat2, na.action = na.exclude)
summary(P3REM)
AIC(P3REM) #1011.239 as of 30/OCT/2023

#P3REM has the lowest AIC yet!

# Model P3REM with nested variance structure for Species/E_load/Treatment definitely DECREASES AIC value. 
plot_model(P3REM, type = "diag")

#Model comparison and selection
MuMIn::model.sel(P1REM, P3REM, P4REM, P5REM)[, c("df", "logLik", "AICc", "delta")]
```

# Conclusions of pathogen model selection with raw functional leaf traits (PATHOGEN)

Model `P3REM` has the lowest AIC score. It has variance structure (`varIdent()`) nested in Species/E_load/Treatment. It also uses an optimizer `lmeControl(opt='optim')`. It is the best model for the pathogen data set, at the moment.

# Figure S8
## Plots: Pathogen

### LM plot

```{r, logit(Pathogen damage) vs Leaf traits and Shannon diversity}

par(mfrow = c(1, 1))
wes_paleta2 <- wes_palette(name = "Darjeeling1", 2, type = "continuous")

# Pathogen Boxplot
pbox <-  ggplot(data = masterpat2, aes(x = Species, y = Pathogen_percent_damage), fill = Species) +
  geom_boxplot(aes(fill = E_load),outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.7) +
  scale_fill_manual(values = wes_paleta2)+
  geom_jitter(color="grey20", size = 1.5, alpha= 0.5) +
  theme_minimal(base_size = 12) +
  theme(legend.position="right", 
         legend.title = element_blank(),
         legend.text = element_text(size = 16),
         axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x="", y="Pathogen Damage (%)", caption = "*All replicate leaves from tree species included  (n = 400)") +
  annotate("text", x = 2.5, y = .65, label = "")
  # stat_compare_means(comparisons = mycomparisons ) +
  # stat_compare_means(method = "kruskal.test", label = "p.signif")
pbox

# Pathogen
# Regressions
# Pathogen damage and Toughness
# Herbivory and Toughness
summary(lm(logit_pathogenicity ~ Toughness, data = masterpat2)) 

patho_lps <- ggplot(data = masterpat2, aes(y= logit_pathogenicity, x = Toughness, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x=expression(paste("Leaf punch strength (N mm","^-1)")), y = "logit[Pathogen damage (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))  +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
patho_lps

# fit <- lm(logit_pathogenicity ~ Thickness, data = masterant2)
# 
# rSquared <- summary(fit)$r.squared
# rSquared
# anova(fit)
# pVal <- anova(fit)$'Pr(>F)'[1]
# pVal

# Pathogen damage and Anthocyanins
summary(lm(logit_pathogenicity ~ Anthocyanins, data = masterpat2))

patho_aci <- ggplot(data = masterpat2, aes(y= logit_pathogenicity, x = Anthocyanins, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x=expression(paste("ACI (% ", italic("A") [lambda]," at 931 nm / % ", italic("A") [lambda]," at 530 nm)")), y = "logit[Pathogen damage (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))  +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
patho_aci
#scale_shape_manual(values = c(1:7))

# Pathogen damage and leaf thickness
summary(lm(logit_pathogenicity ~ Thickness, data = masterpat2))

patho_lt <- ggplot(data = masterpat2, aes(y= logit_pathogenicity, x = Thickness, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x=expression(paste("Leaf thickness (",mu,"m)")), y = "logit[Pathogen damage (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))  +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend

patho_lt

# Pathogen damage and LMA
summary(lm(logit_pathogenicity ~ LMA, data = masterpat2))

patho_lma <- ggplot(data = masterpat2, aes(y= logit_pathogenicity, x = LMA, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x= expression(paste("LMA (mg ",mm^-2, ")")), y = "logit[Pathogen damage (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) 
patho_lma

# Pathogen damage and FEF Shannon Diversity
summary(lm(logit_pathogenicity ~ Shannon, data = masterpat2))

# Extracting effect size of model to plot
patho_shannon <- ggplot(data = masterpat2, aes(y= logit_pathogenicity, x = Shannon, color = E_load)) +
  geom_jitter(aes(color = E_load, shape = Species), 
               size = 3, 
               alpha = 0.7) +
  geom_smooth(method = lm, 
              se = T , 
              level = 0.95, 
              na.rm = F, 
              color = "black", 
              size = 0.75) +
  scale_shape_manual(labels=c("A. membranacea", 
                              "C. cainito", 
                              "C. alliodora", 
                              "Dypterix sp.", 
                              "H. concinna", 
                              "L. panamensis", 
                              "T. cacao"),
                     values = c(15:22)) +
  scale_color_manual(name = "Treatment",
                     labels=c("E-", "E+"),
                     values = met.brewer(name = "Cross", n = 2, type="discrete")) +
  geom_smooth(method=lm, se = F) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y.npc = "top", 
                        label.x.npc = "left",
                        size = 5,
                        aes(label = ..eq.label..), 
                        color= "black") +
  labs(x= "Shannon's Diversity Index", y = "logit[Pathogen damage (%)]") +
  theme_classic(base_size = 10) +
  theme(legend.position="right", 
        legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic",
                                   size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) 
 



 # Multiples plots together

suppfig_S8 <- ggarrange(patho_lt, patho_lps, patho_aci, patho_lma, patho_shannon, 
                          nrow = 2, 
                          ncol=3, 
                          common.legend = TRUE, 
                          labels = c("(a)", "(b)", "(c)", "(d)", "(e)"),
                          legend="bottom")

suppfig_S8
#Saving
#ggsave(filename ="./figures/Aim3_FigS8_21JAN2024.jpg", plot = arranged_with_caption, dpi= 600, units=c("mm"), width=180, height=140, bg = "white")

```

# Table 3
# GLMM tables and estimates for ant and pathogen GLMMs with `logit_herbivory` and `logit_pathogenicity`

### Plotting Estimates (Fixed Effects) of Best Fit model for Ant and Pathogen data sets

Using [`sjPlot`](https://strengejacke.github.io/sjPlot/articles/plot_model_estimates.html) package to visualize model estimates.

```{r, sjPlot visualizations}
# Regression model table

tab_model(M3REM, P3REM, 
          show.aic = TRUE, 
          show.intercept = TRUE, 
          show.df = FALSE,
          show.ci = 0.95,
          title = "Linear mixed effects models for predicting leaf herbivory and pathogenicity", 
          CSS = list(
            css.depvarhead = 'font-weight:bold;',
            css.centeralign = 'text-align: left;',
            css.firsttablecol = 'font-weight: bold;',
            css.summary = 'color: grey; font-weight: bold;',
            p.style = "numeric_stars"))


# Model estimate plots
# Model: Ants
M3REM_coeff <- plot_model(M3REM,
                       type = "est",
                       vline.color = "black",
                       sort.est = TRUE, 
                       transform = NULL,
                       dot.size = 3,
                       value.offset = .4,
                       value.size = 4,
                       title = "Best fit linear mixed effects model coefficients for predicting leaf herbivory") +
  theme_sjplot()
M3REM_coeff

#ggsave(filename="Aim3_GLM_Coeff_estimates.jpeg", plot = modCoeff, dpi=600, units=c("mm"), width=200, height=200)

# Best fit model standarized coeeficients
M5REM_coeff <- plot_model(M5REM, 
                      type = "est", 
                      vline.color = "black", 
                      sort.est = F, 
                      transform = NULL, 
                      dot.size = 3, 
                      value.offset = .4,
                      value.size = 4,
                      title = "Best fit GLM model coefficients for predicting leaf herbivory (standarized coefficients)")  +
  theme_sjplot()
M5REM_coeff
0.#ggsave(filename="Aim3_GLM_STDCoeff_estimates.jpeg", plot = stCoeff, dpi=600, units=c("mm"), width=200, height=200)

# best fit model slope predictions
#slope <- plot_model(M6REM,  type =  "slope")
plot_model(M3REM, type = "resid")
#ggsave(filename = "Aim3_GLMSlope_LeafTraits_06272022.jpeg", plot = slope, dpi=600, units=c("mm"), width=200, height=200)




# Model: Pathogen
# 
P3REM_coeff <- plot_model(P3REM,
                       type = "est",
                       vline.color = "black",
                       sort.est = TRUE, 
                       transform = NULL,
                       dot.size = 3,
                       value.offset = .4,
                       value.size = 4,
                       title = "Best fit linear mixed effects model coefficients for predicting leaf herbivory") +
  theme_sjplot()
P3REM_coeff

```

I believe the best way to represent the model coefficients if through a table no an estimate plot.

# Indicator species analysis

This analysis allows us to determine what endophytes are associated with particular groups (e.g. tree species). According to this vignette from Cáceres ([2022](https://cran.r-project.org/web/packages/indicspecies/vignettes/IndicatorSpeciesAnalysis.html)) `multipatt` function can provides us with Indicators Value Index and correlation index. Both are similar, but the differences lies in the question they help answer. Indicator value index "\[...\]are used for assessing the predictive values of species as indicators of the conditions prevailing in site groups, e.g. for field determination of community types or ecological monitoring." While the correlation index can be used for "\[...\] determining the ecological preferences of species among a set of alternative site groups or site group combinations."

Given this, it will be best to compute a correlation index. This will allow to determine what endophytes are correlated with particular tree species or across treatment types (E-+).

```{r, Indicator species}

#Subset data frame for indicator species analysis
#Community Data
cotu <- left_join(cOTU, ndata2, by = "Sample_name") |>
  select(!c(Trial_type, 
            Trial_Code, 
            Anthocyanins, 
            Thickness,
            Toughness, 
            LMA)) |>
  relocate(Species, E_load, .after = Sample_name)
```

```{r, vector of groups}
#Making vector of groups for `multipatt` analysis
species_corr_matrix <- cotu[, 4:ncol(cotu)]

species <- cotu$Species
eload <- cotu$E_load

multipatt_analysis <- multipatt(species_corr_matrix, species, func = "r.g", control = how(nperm=999)) #By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"
multipatt_analysis
summary(multipatt_analysis, indvalcomp = TRUE)

#round(head(multipatt_analysis$str), 7)
```

```{r, Correcting for Type I errror}
#Correcting for type 1 error and multiple comparisons
#code from this post
#https://stats.stackexchange.com/questions/370724/indiscpecies-multipatt-and-overcoming-multi-comparrisons/401277#401277

#Extract table of stats
multipatt_analysis_sign <- as.data.table(multipatt_analysis$sign, keep.rownames=TRUE)

#Add adjusted p-value
multipatt_analysis_sign[ , p.adj :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
#indval.table <- indval.sign |>
  #mutate(p.value.bh = p.adjust(p.value, method = "BH"))

#Now we can select only the indicators with adjusted significant p-values
multipatt_analysis_sign[p.adj <= 0.05,]

#Renaming the first column
colnames(multipatt_analysis_sign)[1]  <- "OTU" 
```

P-value adjustments are computed with the "BH" method. Which "\[...\] control the false discovery rate, the expected proportion of false discoveries amongst the rejected hypotheses. The false discovery rate is a less stringent condition than the family-wise error rate, so these methods are more powerful than the others." Information for the R documentation page of `p.adjust()`.

Table with taxonomic information. These are OTUs that are significantly correlated with tree species across the whole data set *n* = 156 (individuals that where used for ant and pathogen assay).


### Table of significantly correlated species
#### Table S5
```{r, supptable_S5}
#Table with taxonomic information
multipatt_taxonomy <- left_join(newpqDF, multipatt_analysis_sign, by= c("OTU"))

multipatt_taxonomy <- multipatt_taxonomy |>
  filter(p.adj <= 0.05) |>
  select(!c(9:164)) 

#write.csv(multipatt_taxonomy, "./post_stat_analyses_data/Significant_OTUs.csv")

#Let's clean up the table a bit
#Some Stackoverflow magic
makeStars <- function(x){
  stars <- c("****", "***", "**", "*", "ns")
  vec <- c(0, 0.0001, 0.001, 0.01, 0.05, 1)
  i <- findInterval(x, vec)
  stars[i]
}

supptable_S5 <- gt(multipatt_taxonomy |>
  mutate(across(s.APEIME:s.THEOCA, na_if, 0), Host =
           case_when(s.APEIME  == 1 ~ "A. membranacea",
                     s.CHRYCA == 1 ~ "C. cainito",
                     s.CORDAL == 1 ~ "C. alliodora",
                     s.DYPTE == 1 ~ "Dypterix .sp",
                     s.HEISCO ==1 ~ "H. concinna",
                     s.LACPA == 1 ~ "L. panamensis",
                     s.THEOCA == 1 ~ "T. cacao"),
         p.value = makeStars(p.value)) |>
  select(!c(s.APEIME:s.THEOCA)) |>
  relocate(OTU, Host, .after = species) |>
  rename_with(str_to_title, !OTU), 
  groupname_col = "Host")|>
  tab_options(row_group.as_column = TRUE) |>
  tab_stubhead(label = "Host species") |>
  tab_stub_indent(
   rows = tidyr::starts_with("Fungi"),
   indent = 2
  ) |>
  tab_spanner(
    label = md("Multilevel pattern analysis"),
    columns = c(
      Index:P.adj
    )
  ) |>
  cols_label(
    P.value = md("*p*"),
    P.adj = md("*p*<sub>adj<sub>")
  ) |>
  fmt_number(
    columns = c(Stat:P.adj),
    decimals = 3
  ) |>
  tab_style(
   style = list(
      cell_text(style = "italic")
      ),
    locations = cells_row_groups()
   )|>
  tab_style(
    style = list(
      cell_text(weight = "bold")
      ),
    locations = list(cells_column_labels(), cells_stubhead())
    ) |>
    text_replace(
    locations = cells_body(columns = OTU),
    pattern = "_",
    replacement = " "
  ) |>
     text_replace(
    locations = cells_body(columns = Species),
    pattern = "_",
    replacement = " "
  ) |>
    tab_style(
      style =  cell_text(style = "italic"),
    locations = cells_body(columns = Species)
  ) |>
  tab_header(
    title = md("Taxonomy of significantly correlated OTUs tropical tree host species")) |>
  tab_footnote(
    footnote = md("Significance levels are represented by *ns* (not significant) and asterisks [*p* = 0.05 (\\*), *p* = 0.01 (\\**), *p* = 0.001 (\\***), and *p* < 0.0001 (\\****)]."),
    locations = cells_column_labels(columns = P.value)
  ) |>
  tab_footnote(
    footnote = md("Benjamini & Hochberg method adjustment for multiple comparisons"),
    locations = cells_column_labels(columns = P.adj)
  ) |>
  opt_align_table_header(align = "center") |>
    opt_table_font(
    font = list(
      google_font(name = "Tex Gyre Termes"),
       "serif"
    )
  )
supptable_S5 

#gtsave(supptable_S5, file = "Aim3_supptable_S5_12JAN2024.docx", path = "./tables")
```

## Shannon's diversity index

### "Indicator" species on samples with the **highest and lowest diversity**

Sorting samples with the highest diversity per species (top 10% per species). If it is not done this way we end up with the top 10% of the whole data set and that turns out to be *Theobroma cacao*. Similar for the bottom 10%.

```{r, Ant data set top/bottom 3}
# n <- 0.1 * nrow(master)

# 3 plants with highest Shannon diversity
antop3 <- masterant |>
  group_by(Species) |>
  slice_max(order_by = Shannon, n = 3) |>
  select(Species, Sample_name, E_load, Shannon)
#Top 3 plants with the highest FEF diversity per Species.

  
  #  group_by(Species) |>
  # summarise(across(c(Sample_name, E_load, Shannon), .fns = ~sort(.x, decreasing = T)[1:3])) #Old way of filtering the data. It selected the top 3 values for Sample_name and then Shannon, which then mismatched Samples with Shannon values. 



# 3 plants with the lowest Shannon diversity
anbot3 <- masterant |>
  group_by(Species) |>
  slice_min(order_by = Shannon, n = 3) |>
  select(Species, Sample_name, E_load, Shannon)

#This data frame is meant to be used as a filter to select samples from community data frame (cotu).

```

After trying to capture the samples with the top 10% diversity I realize that on a per species level that would mean 1 plant per species. There are 10 plant/samples per species and 7 tree species. I changed the approach. Now we are looking at the 3 most diverse samples per tree species. The same method will be applied to the lowest 10%.

We see that 4/21 are E-:E+ are selected as the top 3 with the highest diversity. While, the lowest diversity plants are split 11/21 E-:E+. We are selecting the top 3 of the data frame for ant and pathogen assays respectively.


# Recoding upper and lower 30% herbivory and pathogen damage as High and Low
 
The idea is to use this data frame for a new `multipatt` analysis where we compare the groups. Point biserial correlation coefficient analysis require a discrete variable, hence the new High and Low categories. 

```{r, Recoding upper/lower}
# 
upper_lower_damage <- master |>
  mutate(
    herbivory_level = case_when(Ant_percent_leafloss  >= 70 ~ "high",
                                Ant_percent_leafloss %between% list(31,69) ~ "medium",
                                 Ant_percent_leafloss <= 30 ~ "low"),
    pathogen_level = case_when(Pathogen_percent_damage >= 30 ~ "high",
                               Pathogen_percent_damage <= 29 ~ "low")) |>
  filter(!(is.na(herbivory_level) & is.na(pathogen_level))) |> #Dropping NAs in both columns
  select(c(Sample_name, Species, E_load, Treatment, herbivory_level, pathogen_level)) #Droping Ant_percent_leafloss and Pathogen_percent_damage
#196 observations and 6 variables
```

Some species had about half the individuals experience less that 30% leaf damage. For the highest 70% damaged, 5/13 are E+ plants. <- Was this for ant herbivory damage?

The pathogen data shows less than 40% leaf damage for almost all plants, controls and treatments (114/128). The focus here is comparing control and treatment leaf across E+ and E- treatments. The cut off here will be 30%. What is below? The E+ samples or the E-? It looks like 14 trees have more than 30% leaf damage and 5/14 are E-. We expected the opposite: more damage on tree with less FEF abundance.

### Filtering the community data frame with the highest/lowest leaf area damaged.

```{r, Filtering damage}
#Some filtering and joining
leaf_damage_filter <- inner_join(upper_lower_damage, cotu, join_by(Sample_name, Species, E_load))#Should result in 196 observations and 575 variables

#Anti join check
filter_filter <- anti_join(leaf_damage_filter, cotu, by = c("Sample_name")) #should turn 0 observations and 575 variables
```

This filtering join should result in 196 observations and 575 variables. It has 40 more observations than `cotu` because some samples are "duplicated". Meaning same plant but 2 different treatment levels (control and pathogen).

### Leaf damage: Correlation of OTUs with High and Low leaf damage (herbivory and pathogenicity)

The `multipatt` function does not allow for NAs or non-conformable arguments. This means I need to subset the data set for herbivory and pathogen damage levels.

```{r, Highest/lowest leaf damage herbivore and pathogen indicator species}
# Recoded dataset for indicator species analysis
#Making vector of groups for analysis

#NA removal
herb_recoded_filtered <- leaf_damage_filter |>
  filter(!(is.na(herbivory_level)))

#Removal of first 6 columns. Tidyverse solution resulted in the addition of "missing grouping variables" error.
herb_recoded_filtered <- herb_recoded_filtered[, 7:ncol(herb_recoded_filtered)]

#High and low leaf damage by herbivory analysis
#Comparing High and Low groups: What OTUs are corrrelated with these groups?
herb_level <- na.omit(leaf_damage_filter$herbivory_level)

herb_multipatt = multipatt(herb_recoded_filtered, herb_level, func = "r.g", control = how(nperm=999))

#By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"

summary(herb_multipatt, indvalcomp = TRUE)

#High and low leaf damage by pathogen analysis
#NA removal
patho_recoded_filtered <- leaf_damage_filter |>
  filter(!(is.na(pathogen_level)))

#Removal of first 6 columns.
patho_recoded_filtered <- patho_recoded_filtered[, 7:ncol(patho_recoded_filtered)]

#Comparing High and Low groups: What OTUs are corrrelated with these groups?
patho_level <- na.omit(leaf_damage_filter$pathogen_level)

patho_multipatt = multipatt(patho_recoded_filtered, patho_level, func = "r.g", control = how(nperm=999))

summary(patho_multipatt, indvalcomp = TRUE)
```

For herbivory damaged leaves:
Indicator/correlation species analysis for samples with the highest leaf damage (\>70%) we see 13 OTUs siginificantly assciated, while only 1 OTU for the lowest leaf damage (\<30%). For samples in the medium range we see that 3 OTUs are significantly correlated with the group.

For pathogen damaged leaves:
Zero OTUs significantly correlated with the leaves that were damaged \<30% by pathogen. On the other hand, 13 OTUs are significantly correlated with plants that experienced \>30% leaf damage.

#### Herbivory damage
```{r, Type I error and data table for herbivory damage}
#Herbivory results
#Extract table of stats
herb_multipatt_sign <- as.data.table(herb_multipatt$sign, keep.rownames=TRUE)

#Add adjusted p-value
herb_multipatt_sign[ , p.adj :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(herb_levels) are small. 

#Now can select only the indicators with significant p-values
herb_multipatt_corrected <- herb_multipatt_sign[p.value <= 0.05,]

#renaming the first column
colnames(herb_multipatt_corrected)[1]  <- "OTU" 
```

##### Table S6
```{r, supptable_S6}
#Table of OTUs and respective taxonomic information that are significantly correlated to high and low leaf herbivory damage
herb_multipatt_taxonomy <- left_join(newpqDF, herb_multipatt_corrected, join_by(OTU))

herb_multipatt_taxonomy <- herb_multipatt_taxonomy |>
  filter(p.value <= 0.05) |>
  select(!c(9:164)) |>
  as_tibble()

#Saving table
#write.csv(herb_multipatt_taxonomy, "./post_stat_analyses_data/high_low_herbivory_OTUs.csv")
# gt table

#Let's clean up the table a bit
#Some Stackoverflow magic
makeStars <- function(x){
  stars <- c("****", "***", "**", "*", "ns")
  vec <- c(0, 0.0001, 0.001, 0.01, 0.05, 1)
  i <- findInterval(x, vec)
  stars[i]
}

supptable_S6 <- gt(herb_multipatt_taxonomy |>
  mutate(across(s.high:s.medium, na_if, 0), Herbivory =
           case_when(s.high  == 1 ~ "High",
                                s.medium == 1 ~ "Medium",
                                 s.low == 1 ~ "Low"),
         p.value = makeStars(p.value)) |>
  select(!c(s.high:s.medium)) |>
  relocate(OTU, Herbivory, .after = species) |>
  rename_with(str_to_title, !OTU), 
  groupname_col = "Herbivory")|>
  tab_options(row_group.as_column = TRUE) |>
  tab_stubhead(label = "Herbivory damage") |>
  tab_stub_indent(
    rows = tidyr::starts_with("Fungi"),
    indent = 2
  ) |>
  tab_spanner(
    label = md("Multilevel pattern analysis"),
    columns = c(
      Index:P.adj
    )
  ) |>
  cols_label(
    P.value = md("*p*"),
    P.adj = md("*p*<sub>adj<sub>")
  ) |>
  fmt_number(
    columns = c(Stat:P.adj),
    decimals = 3
  ) |>
  tab_style(
    style = list(
      cell_text(weight = "bold")
      ),
    locations = list(cells_column_labels(), cells_stubhead())
    ) |>
    text_replace(
    locations = cells_body(columns = OTU),
    pattern = "_",
    replacement = " "
  ) |>
     text_replace(
    locations = cells_body(columns = Species),
    pattern = "_",
    replacement = " "
  ) |>
    tab_style(
      style =  cell_text(style = "italic"),
    locations = cells_body(columns = Species)
  ) |>
  tab_header(
    title = md("Taxonomy of significantly correlated OTUs with *Atta colombica* herbivory levels")) |>
  tab_footnote(
    footnote = md("High = >70% leaf area damage, Medium = 31-69% leaf area damage, Low = <30% leaf area damage"),
    locations = cells_stubhead()
  ) |>
  tab_footnote(
    footnote = md("Significance levels are represented by *ns* (not significant) and asterisks [*p* = 0.05 (\\*), *p* = 0.01 (\\**), *p* = 0.001 (\\***), and *p* < 0.0001 (\\****)]."),
    locations = cells_column_labels(columns = P.value)
  ) |>
  tab_footnote(
    footnote = md("Benjamini & Hochberg method adjustment for multiple comparisons"),
    locations = cells_column_labels(columns = P.adj)
  ) |>
  opt_align_table_header(align = "center") |>
    opt_table_font(
    font = list(
      google_font(name = "Tex Gyre Termes"),
       "serif"
    )
  )
supptable_S6 

#gtsave(supptable_S6, file = "Aim3_supptable_S6_12JAN2024.docx", path = "./tables")
```

#### Pathogen damage
```{r, Type I error and data table for pathogen damage}
#Pathogen damage results
#Extract table of stats
patho_multipatt_sign <- as.data.table(patho_multipatt$sign, keep.rownames=TRUE)

#Add adjusted p-value
patho_multipatt_sign[ , p.adj :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(patho_levels) are small. 

#Now can select only the indicators with significant p-values
patho_multipatt_corrected <- patho_multipatt_sign[p.value <= 0.05,]

#renaming the first column
colnames(patho_multipatt_corrected)[1]  <- "OTU" 
```

##### Table S7
```{r, supptable_S7}
#Table of OTUs and respective taxonomic information that are significantly correlated to high and low leaf pathoivory damage
patho_multipatt_taxonomy <- left_join(newpqDF, patho_multipatt_corrected, join_by(OTU))

patho_multipatt_taxonomy <- patho_multipatt_taxonomy |>
  filter(p.value <= 0.05) |>
  select(!c(9:164)) 

#Saving table
#write.csv(patho_multipatt_taxonomy, "./post_stat_analyses_data/high_low_pathogen_OTUs.csv")
# gt table
#Let's clean up the table a bit
#Some Stackoverflow magic
makeStars <- function(x){
  stars <- c("****", "***", "**", "*", "ns")
  vec <- c(0, 0.0001, 0.001, 0.01, 0.05, 1)
  i <- findInterval(x, vec)
  stars[i]
}

supptable_S7 <- gt(patho_multipatt_taxonomy |>
  mutate(across(s.high:s.low, na_if, 0), Pathogen =
           case_when(s.high  == 1 ~ "High",
                                 s.low == 1 ~ "Low"),
         p.value = makeStars(p.value)) |>
  select(!c(s.high:s.low)) |>
  relocate(OTU, Pathogen, .after = species) |>
  rename_with(str_to_title, !OTU), 
  groupname_col = "Pathogen")|>
  tab_options(row_group.as_column = TRUE) |>
  tab_stubhead(label = "Pathogen damage") |>
  tab_stub_indent(
    rows = tidyr::starts_with("Fungi"),
    indent = 2
  ) |>
  tab_spanner(
    label = md("Multilevel pattern analysis"),
    columns = c(
      Index:P.adj
    )
  ) |>
  cols_label(
    P.value = md("*p*"),
    P.adj = md("*p*<sub>adj<sub>")
  ) |>
  tab_style(
    style = list(
      cell_text(weight = "bold")
      ),
    locations = list(cells_column_labels(), cells_stubhead())
    ) |>
    text_replace(
    locations = cells_body(columns = OTU),
    pattern = "_",
    replacement = " "
  ) |>
     text_replace(
    locations = cells_body(columns = Species),
    pattern = "_",
    replacement = " "
  ) |>
    tab_style(
      style =  cell_text(style = "italic"),
    locations = cells_body(columns = Species)
  ) |>
    fmt_number(
    columns = c(Stat:P.adj),
    decimals = 3
  ) |>
  tab_header(
    title = md("Taxonomy of significantly correlated OTUs with *Calonectria* sp. pathogen dasmge levels")) |>
  tab_footnote(
    footnote = md("High = >30% leaf area damage, Low = <29% leaf area damage"),
    locations = cells_stubhead()
  ) |>
  tab_footnote(
    footnote = md("Significance levels are represented by *ns* (not significant) and asterisks [*p* = 0.05 (\\*), *p* = 0.01 (\\**), *p* = 0.001 (\\***), and *p* < 0.0001 (\\****)]."),
    locations = cells_column_labels(columns = P.value)
  ) |>
  tab_footnote(
    footnote = md("Benjamini & Hochberg method adjustment for multiple comparisons"),
    locations = cells_column_labels(columns = P.adj)
  ) |>
  opt_align_table_header(align = "center") |>
    opt_table_font(
    font = list(
      google_font(name = "Tex Gyre Termes"),
       "serif"
    )
  )
supptable_S7 

#gtsave(supptable_S7, file = "Aim3_supptable_S7_12JAN2024.docx", path = "./tables")
```
The plants least damaged by pathogen have 92 OTUs significantly correlated with them (*p-value* \< 0.05). When adjusted for multiples comparison ("bh") the result is 20 OTUs.

#EXTRA
Lines of inquiry not pursued in the paper but that may be of interest for further analyses.
# Dimensionality Reduction of leaf traits

## LDA: Linear Discriminant Analyses

"Before performing LDA, consider: Inspecting the univariate distributions of each variable and make sure that they are normally distribute. If not, you can transform them using log and root for exponential distributions and Box-Cox for skewed distributions. removing outliers from your data and standardize the variables to make their scale comparable." <http://www.sthda.com/english/articles/36-classification-methods-essentials/146-discriminant-analysis-essentials-in-r/>

### LDA training

```{r, Ant LDA training}
#Analysis based on C. Lumibao code
#Transform and standarize leaf trait data. They are in different scales and a not normally distributed. 

#Ant
####### Data prep #######
#Subsetting the columns from the data set in order to transform and scale leaf trait variables and diversity measures.

ant_labels <- masterant[,1:4]
ant_std<-masterant[,6:15]

#Scaling
antsc_trait <- scale(ant_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
ant_lda <- cbind(ant_labels, antsc_trait)


#### Training model ####
#### Splitting the data into training (80%) and test set (20%)

lda.training <- ant_lda |>
  slice_sample(prop = 0.8)

lda.test <- ant_lda |>
  slice_sample( prop = 0.2)

### Training ###
lda_train <- lda(Species ~ Anthocyanins * LMA  * Thickness * Toughness * E_load * Shannon * Total_leaf_area_cut,
            data = lda.training, method = "moment")

# Model accuracy
mean(predict(lda_train)$class == lda.test$Species)
#0.1428571

predictions <- lda_train |> 
  predict(lda.test) #I believe this is saying: predict `lda.test` with the values from `lda_train`.

# Plot training data 
lda.data <- cbind(lda.training, predict(lda_train)$x)

ldaplot <- ggplot(lda.data, aes(LD1, LD2)) 
  ldaplot + geom_point(data = lda.data, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7)

# Model accuracy
mean(predictions$class == lda.test$Species)
xtabs(~lda.training$Species + predict(lda_train)$class)

```

Conclusion: The ant LDA training model accurately (100%) discriminates the test data set. Modelling interactions achieves 100% accuracy. This validates our model which can be important. Now we proceed with all the data points.

```{r, Pathogen LDA training}
# Pathogen
# Data prep 
#Subsetting the columns from the data set in order to transform and scale leaf trait variables and diversity measures.

pg_labels <- masterpat[,1:6]
pg_std<-masterpat[,7:16]

#Scaling
pgsc_trait <- scale(pg_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
pg_lda <- cbind(pg_labels, pgsc_trait)


# Training model 
## Splitting the data into training (80%) and test set (20%)

pglda.training <- pg_lda |>
  slice_sample(prop = 0.75)

pglda.test <- pg_lda |>
  slice_sample( prop = 0.25)

## Training
pglda_train <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + E_load + Shannon + Pathogen_Damage_area,
            data = pglda.training, method="moment")

# Model accuracy
mean(predict(pglda_train)$class == pglda.test$Species)
#0.1354167

predictions2 <- pglda_train |> 
  predict(pglda.test) #I believe this is saying: predict `lda.test` with the values from `lda_train`.

# Plot training data 
pglda.data <- cbind(pglda.training, predict(pglda_train)$x)

pgldaplot <- ggplot(pglda.data, aes(LD1, LD2)) 
  pgldaplot + geom_jitter(data = pglda.data, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7)

# Model accuracy
mean(predictions2$class == pglda.test$Species)
#100% accurate

xtabs(~pglda.training$Species + predict(pglda_train)$class)
```

Conclusion: The pathogen training model accurately (100%) discriminates the test data set. The model does not include interaction to achieve 100% accuracy in linear discrimination. This validates our model which can be important. Now we proceed with all the data points.

### LDA: Full models with functional leaf traits and Shannon diversity

#### Ant

```{r, Ant LDA with all functional leaf traits}
# Ants

#LDA cannot have NA's if not it will result in Error in x - group.means[g, ] : non-conformable arrays.
#

#This model is asked to discriminate per Species.

ld2a <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + Shannon,
            data = ant_lda, method="moment")

#Model predictions into list
lda.values <- predict(ld2a)

#Model scores
ld2a$scores <- predict(ld2a)$x #coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
ld2b <- data.frame(varnames = rownames(coef(ld2a)), coef(ld2a))
ld2b$length <- with(ld2b, sqrt(LD1^2+LD2^2))
# scaling <- data.frame(ld2a$scaling) #Another way of extracting model coefficients.
# scaling <- scaling |>
#   rownames_to_column(var = "varnames") |>
#   mutate(length = sqrt(LD1^2+LD2^2))


#only the x variables from predict
ldax <- as.data.frame(lda.values$x)
row.names(ldax)

#Write the predicted values for each samples as a table.
LDtraits <- cbind(ant_lda,ldax)
LDtraits # Use for ggplots


#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDtraits$Species == lda.values$class)

xtabs(~LDtraits$Species + lda.values$class)

#The model is 90% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.lda = ld2a$svd^2/sum(ld2a$svd^2)

#LDA full model plot with ggplot

ldafull <- ggplot(LDtraits, aes(LD1, LD2)) +
  geom_point(data = LDtraits, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = ld2b,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = ld2b,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.lda[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Ants LDA: all E-+, leaf traits and Shannon diversity", caption = "(90% accuracy)", y = paste("LD2 (", round(prop.lda[2]*100, digits = 1), "%)", sep="")) +  
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   theme(
plot.title = element_text(color="red", size=14, face="bold"))

ldafull 

#ggsave(filename = "plots/LDAfull_02282023.png", plot = ldafull, dpi=600, units=c("mm"), width=300, height=300)

```

The full model is 90% accurate is discriminating species groups. This is probably due to only modelling fixed effects. No interaction terms are modeled. Previous LDA model (with no Shannon diversity included) had an accuracy of 88% and LD1 and LD2 differed by \~0.5%. Code was updated in February 28, 2023 to include Shannon diversity.

#### Pathogen

```{r, Pathogen LDA with all functional leaf traits}
#Pathogen
# Data prep 
#Subsetting the columns from the data set in order to transform and scale leaf trait variables and diversity measures.

pg_labels <- masterpat[,1:6]
pg_std<-masterpat[,7:16]

#Scaling
pgsc_trait <- scale(pg_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
pg_lda <- cbind(pg_labels, pgsc_trait)


## LDA
pglda <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + Shannon,
            data = pg_lda, method = "moment")


#Model predictions into list
pglda.values <- predict(pglda)

#Model scores
pglda$scores <- predict(pglda)$x

#coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
pgld2b <- data.frame(varnames = rownames(coef(pglda)), coef(pglda))
pgld2b$length <- with(pgld2b, sqrt(LD1^2+LD2^2))
# scaling <- data.frame(ld2a$scaling) #Another way of extracting model coefficients.
# scaling <- scaling |>
#   rownames_to_column(var = "varnames") |>
#   mutate(length = sqrt(LD1^2+LD2^2))


#only the x variables from predict
pgldax <- as.data.frame(pglda.values$x)
row.names(pgldax)

#Write the predicted values for each samples as a table.
LDPGtraits <- cbind(pg_lda,pgldax)
LDPGtraits # Use for ggplots


#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDPGtraits$Species == pglda.values$class)

xtabs(~LDPGtraits$Species + pglda.values$class)

#The model is 95.3% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.pg = pglda$svd^2/sum(pglda$svd^2)

pgldaplot <- ggplot(LDPGtraits, aes(LD1, LD2)) +
  geom_point(data = LDPGtraits, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = pgld2b,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = pgld2b,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.lda[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Pathogen LDA: E-+, leaf traits and Shanno diversity", caption = "(95% accuracy)", y = paste("LD2 (", round(prop.lda[2]*100, digits = 1), "%)", sep="")) +  
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   theme(
plot.title = element_text(color="red", size=14, face="bold"))

pgldaplot

#ggsave(filename = "plots/Path_LDAfull_02282023.png", plot = pgldaplot, dpi=600, units=c("mm"), width=300, height=300)

```

```{r, LDA model with interactions}
# LDA with interactions #############

ld2c <- lda(Species ~ Anthocyanins * LMA  * Thickness * Toughness * E_load * Shannon * Total_leaf_area_cut,
            data = ant_lda, method="moment")

#Model predictions into list
ldac.values <- predict(ld2c)

#Model scores
ld2c$scores <- predict(ld2c)$x

#coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
ld2d <- data.frame(varnames = rownames(coef(ld2c)), coef(ld2c))

ld2d$length <- with(ld2d, sqrt(LD1^2+LD2^2))

#only the x variables from predict
ldacx <- as.data.frame(ldac.values$x)
row.names(ldacx)

#Write the predicted values for each samples as a table.
LDCtraits <- cbind(ant_lda,ldacx)
LDCtraits # Use for ggplots

row.names(ld2c$scaling)
#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDCtraits$Species == ldac.values$class)

xtabs(~LDCtraits$Species + ldac.values$class)

#The model is 100% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.ldac = ld2c$svd^2/sum(ld2c$svd^2)

#LDA full model plot with ggplot

ldainter <- ggplot(LDCtraits, aes(LD1, LD2)) +
  geom_point(data = LDCtraits, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = ld2d,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = ld2b,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.ldac[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Full model LDA with interactions", caption = "100% accuracy", y = paste("LD2 (", round(prop.ldac[2]*100, digits = 1), "%)", sep="")) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme(
plot.title = element_text(color="red", size=14, face="bold.italic"))

ldainter

#ggsave(filename = "LDAinter.png", plot = ldainter, dpi=600, units=c("mm"), width=300, height=300)
```

Modelling the interaction does achieve 100% accuracy but it is harder to interpret. The plot for model with interaction terms is harder to interpret. The arrow labels over lap and are not readable.

### LDA: E+ models

The objective here is to model what leaf traits are important for discriminating between groups with differing endophyte loads. Focusing on the endophyte load allows us to understand if E+ and E- are distinguishable.

```{r, Ant E_load models}
### Data prep ###
### subset for E+ samples
ant_Elab <- masterant |>
  filter(E_load == "E+")

e_labs <- ant_Elab[,1:4]
e_std <- ant_Elab[,6:15]

#Scaling
esc_trait <- scale(e_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
e_lda <- cbind(e_labs, esc_trait)

lde <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + Shannon,
            data = e_lda, method = "moment")

#Model predictions into list
lde.values <- predict(lde)

#Model scores
lde$scores <- predict(lde)$x

#coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
ld2e <- data.frame(varnames = rownames(coef(lde)), coef(lde))

ld2e$length <- with(ld2e, sqrt(LD1^2+LD2^2))

#only the x variables from predict
ldex <- as.data.frame(lde.values$x)
row.names(ldex)

#Write the predicted values for each samples as a table.
LDEtraits <- cbind(e_lda,ldex)
LDEtraits # Use for ggplots and linear mixed models

row.names(ld2e$scaling)
#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDEtraits$Species == lde.values$class)

xtabs(~LDEtraits$Species + lde.values$class)

#The model is 97% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.lde = lde$svd^2/sum(lde$svd^2)

#LDA E+ full model plot with ggplot
ldee <- ggplot(LDEtraits, aes(LD1, LD2)) +
  geom_point(data = LDEtraits, aes(color = Species), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = ld2e,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = ld2e,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.lde[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Ant E+ LDA: leaf traits and Shannon diversity", caption = "(97% accuracy)", y = paste("LD2 (", round(prop.lde[2]*100, digits = 1), "%)", sep="")) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   theme(
plot.title = element_text(color="red", size=14, face="bold"))

ldee


#ggsave(filename = "plots/Ant_LDA_Eplus02282023.png", plot = ldee, dpi=600, units=c("mm"), width=300, height=300)
```

The November 2022 iteration of this plot had similar values for LD1 and LD2. What is different now (02282023) is how the traits are "driving" the discrimination of the groups. Leaf toughness, thickness and LMA are in the upper half of the plot, opposite to anthocyanins in LD2. Additionally, leaf toughness and thickness align opposite to each other in LD1. Shannon diversity does not seam to be important for distinguishing the groups.

```{r, Pathogen E_load models}
### Data prep ###
### subset for E+ samples
pat_Elab <- masterpat |>
  filter(E_load == "E+")

pe_labs <- pat_Elab[,1:6]
pe_std <- pat_Elab[,7:16]

#Scaling
psc_trait <- scale(pe_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
pe_lda <- cbind(pe_labs, psc_trait)

ldep <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + Shannon,
            data = pe_lda, method="moment")

#Model predictions into list
ldep.values <- predict(ldep)

#Model scores
ldep$scores <- predict(ldep)$x

#coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
ld2ep <- data.frame(varnames = rownames(coef(ldep)), coef(ldep))
ld2ep$length <- with(ld2ep, sqrt(LD1^2+LD2^2))

#only the x variables from predict
ldepx <- as.data.frame(ldep.values$x)
row.names(ldepx)

#Write the predicted values for each samples as a table.
LDEPtraits <- cbind(pe_lda,ldepx)
LDEPtraits # Use for ggplots and linear mixed models

#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDEPtraits$Species == ldep.values$class)

xtabs(~LDEPtraits$Species + ldep.values$class)

#The model is 100% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.ldep = ldep$svd^2/sum(ldep$svd^2)

#LDA E+ full model plot with ggplot
ldeep <- ggplot(LDEPtraits, aes(LD1, LD2)) +
  geom_point(data = LDEPtraits, aes(color = Species), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = ld2ep,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = ld2ep,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.ldep[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Pathogen E+ LDA: leaf traits and Shannon diversity", caption = "(100% accuracy)", y = paste("LD2 (", round(prop.ldep[2]*100, digits = 1), "%)", sep="")) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   theme(
plot.title = element_text(color="red", size=14, face="bold"))

ldeep  

# ggsave(filename = "plots/Path_LDA_Eplus_02282023.png", plot = ldeep, dpi=600, units=c("mm"), width=300, height=300)

```

Again, very similar to previous results. Looking closely at the plots from 11/2022 I see that some of the were calculated with Shannon diversity. This explain why the results are so similar or the same. BAR-02282023

# LDA: simple linear regression models

We have reduced the number of leaf traits by computing an LDA for ant and pathogen trials. This reduced the number of covariates to two synthetic ones that explain the most variance in the model: LD1 and LD2. Now, we proceed to compute simple linear regressions with LD1 and LD2 as the fixed effects for the models, while adding biological trait measurements (i.e. Shannon diversity).

The LD's from data frames `LDtraits` and `LDPGtraits` are computed with all the data points (i.e. E+ and E- samples) for each trial type. The LD's from data frames `LDEtraits` and `LDEPtraits` are computed with the E+ samples.

### Ant

```{r, Ant LDA regression, tidy = FALSE}
# Use LDA loadings to model effects ant herbivory

# Null model
lm1 <- lm(Total_leaf_area_cut ~ 1, data = LDEtraits)
summary(lm1)
#plot(lm1)

plot_model(lm1, type = "diag")

# Model 1 
lm2 <- lm(Total_leaf_area_cut ~ LD1 + LD2, data = LDEtraits)
summary(lm2)
# Residuals
# lm2_resid <- resid(lm2, type = "response")
# lm2_fitted <- fitted(lm2)
#Histograms
# hist(lm2_resid)
# hist(lm2_fitted)

#lm2 model plot
plot_model(lm2, type = "diag")
AIC(lm2) #106.7782 This is slightly higher than lm1.

# Model comparison
anova(lm1, lm2)

#step(lm2, direction = "both") #Warning: attempting model selection on an essentially perfect fit is nonsense
############
ant_ld1reg <- ggplot(LDEtraits, aes(LD1, Total_leaf_area_cut)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Herbivory by leaf cutter ants vs. LD1", y = "Total leaf area cut", caption = "LD1 explains the most variance in LDA model.") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))
  
ant_ld1reg

#ggsave(filename = "Ant_LD1_Reg.png", plot = ant_ld1reg, dpi=600, units=c("mm"), width=300, height=300)
#
#LD2
ant_ldareg <- ggplot(LDEtraits, aes(LD2, Total_leaf_area_cut)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Herbivory by leaf cutter ants vs. LD2", y = "Total leaf area cut", caption = "LD2 is the most significant predictor in LMM.") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))
  
ant_ldareg

#ggsave(filename = "Ant_LD2_Reg.png", plot = ant_ldareg, dpi=600, units=c("mm"), width=300, height=300)
#
#Shannon Diversity

ant_ldashannon <- ggplot(LDEtraits, aes(Shannon, Total_leaf_area_cut)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Herbivory by leaf cutter ants vs. Shannon diversity", y = "Total leaf area cut") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))

ant_ldashannon

#ggsave(filename = "Ant_LDA_shannon.png", plot = ant_ldashannon, dpi=600, units=c("mm"), width=300, height=300)

```

### Pathogen

```{r}
# Use LDA loadings to model effects ant herbivory

# Null model
pm1 <- lm(Pathogen_Damage_area~ 1, data = LDEPtraits)
summary(pm1)
#plot(pm1)
plot_model(pm1, type = "diag")

# Model 1 
pm2 <- lm(Pathogen_Damage_area ~ LD1 + LD2 + Shannon, data = LDEPtraits)
summary(pm2)
# Residuals
# lm2_resid <- resid(lm2, type = "response")
# lm2_fitted <- fitted(lm2)
#Histograms
# hist(lm2_resid)
# hist(lm2_fitted)

#lm2 model plot
plot_model(pm2, type = "diag")
AIC(pm2)

# Model comparison
anova(pm1, pm2)

#step(pm2, direction = "both") #Warning: attempting model selection on an essentially perfect fit is nonsense
############
#LD1
pat_ld1reg <- ggplot(LDEPtraits, aes(LD1, Pathogen_Damage_area)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Pathogen Leaf Damage vs. LD1", y = "Total pathogen damaged area", caption = "LD1 explains the most variance in the LDA model") +
  theme(plot.title = element_text(color="red", size=14, face="bold.italic"))
  
pat_ld1reg

#ggsave(filename = "Pat_LD1_Reg.png", plot = pat_ld1reg, dpi=600, units=c("mm"), width=300, height=300)
#
#LD2
pat_ld2reg <- ggplot(LDEPtraits, aes(LD2, Pathogen_Damage_area)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Pathogen Leaf Damage vs. LD2", y = "Total pathogen damaged area") +
  theme(plot.title = element_text(color="red", size=14, face="bold.italic"))
  
pat_ld2reg

#ggsave(filename = "Pat_LD2_Reg.png", plot = pat_ld2reg, dpi=600, units=c("mm"), width=300, height=300)
#
#Shannon diversity

pat_lda_shannon <- ggplot(LDEPtraits, aes(Shannon, Pathogen_Damage_area)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Pathogen Leaf Damage vs. Shannon diversity", y = "Total pathogen damaged area") +
  theme(plot.title = element_text(color="red", size=14, face="bold.italic"))
  
pat_lda_shannon

#ggsave(filename = "Pat_LDA_shannon.png", plot = pat_lda_shannon, dpi=600, units=c("mm"), width=300, height=300)
```

# LDA: Linear Mixed Models

In the section above, we see that the diagnostics plots for simple linear regressions with the ant and pathogen data have a fair amount of heteroskedasticity. Meaning, there is an un-even or non-random distribution of the residuals. They resemble more a triangle or fan-like distribution. In this section, I attempt to optimize by changing the estimation methos and applying optimizers to the distribution of the residuals with generalized linear mixed models (e.g. `bobyqa`)or linear mixed effects models (e.g. `nlminb`) .

Initial models with `nlme` package use "Maximum Likelihood", then "REML" and `Species` or `E_load` as random effects.

## Ants

### ML-ants

```{r, Ant Maximum Likelihood model selection}
#nlme package
#Model1
aglm <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "ML", data = LDEtraits)

summary(aglm)
AIC(aglm) # 108.5
plot_model(aglm, type = "diag")

#Model2
aglm2 <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species/E_load, method = "ML", data = LDEtraits)

summary(aglm2)
AIC(aglm2) #110.5
plot_model(aglm2, type = "diag")

#Model3 interactions
aglm3 <- lme(Total_leaf_area_cut ~ LD1 * LD2, random = ~1|Species/E_load, method = "ML", data = LDEtraits)

summary(aglm3)
AIC(aglm3) #111.5
plot_model(aglm3, type = "diag")


tab_model(aglm, aglm2, aglm3, show.re.var = T, show.aic = TRUE, show.intercept = TRUE, title = "LMM Maximum Likelihood Ant damage", CSS = list(
    css.depvarhead = 'font-weight:bold;',
    css.centeralign = 'text-align: left;', 
    css.firsttablecol = 'font-weight: bold;',
    css.summary = 'color: blue; font-weight: bold;',
     dv.labels = c("aglm ", "aglm2", "aglm3"),
    p.style = "numeric_stars"))
```

```{r, Ant Model validation}
aglm_resid <- resid(aglm, type = "response")
aglm_fitted <- fitted(aglm)

plot(aglm_resid)
plot(aglm_fitted)

# Visual Model Validation

op <- par(mfrow = c(2, 2), mar = c(4, 4, 2, 2))
plot(LDEtraits$LD1, jitter(resid(aglm, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
```

### REML-ants

```{r, Ant Restricted Maximum Likelihood models}
#  < - glmer(Total_leaf_area_cut ~ LD1 + LD2 + Shannon + (1| Species) + (1| E_load), data = LDEtraits, family = "poisson", control = glmerControl(optimizer="bobyqa"))

areml <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "REML", data = LDEtraits) 

summary(areml)
AIC(areml) #118.6
plot_model(areml, type = "diag")

tab_model(aglm, areml, show.re.var = T, show.aic = TRUE, show.intercept = TRUE, title = "LMM Maximum Likelihood Ant damage", CSS = list(
    css.depvarhead = 'font-weight:bold;',
    css.centeralign = 'text-align: left;', 
    css.firsttablecol = 'font-weight: bold;',
    css.summary = 'font-weight: bold;',
    dv.labels = c("aglm ", "areml"),
    p.style = "numeric_stars"))


```

Model estimation with REML increases AIC. Proceeding with ML model estimation.

### Random effects-ants

```{r, Checking contribution of random effects-ants}

agls <- gls(Total_leaf_area_cut ~ LD1 + LD2, method = "ML", data = LDEtraits)

AIC(aglm, agls)
anova(aglm, agls)
#  

```

Species as a random effect increases AIC value by two points. Not that much, and it is worth keeping because it's biological relevance to the questions.

### ML-2-ants

Continuation of previous ML section. Modelling variance structure with `varIdent`, `varExp` and `varComb`.

```{r, Ant Modelling Variance Structure}
#varIdent
aglm_ident <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "ML", weights = varIdent(form = ~ 1|Species), control =  lmeControl(opt= 'nlminb'),  data = LDEtraits)

AIC(aglm_ident) #AIC  = 97
summary(aglm_ident)
Anova(aglm_ident, type = "III")

plot_model(aglm_ident, type= "diag")

#Modelling variance structure with varIdent returns a lower AIC value (97.08464)
#

# Model validation
op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
plot(LDEtraits$LD1, jitter(resid(aglm_ident, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD1, jitter(resid(aglm_ident, type = "normalized")), xlab = "LD1", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm_ident, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm_ident, type = "normalized")), xlab = "LD2", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_ident, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_ident, type = "normalized")), xlab = "Shannon", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")

#
par(mfrow = c(1,2))
plot(fitted(aglm_ident), resid(aglm_ident, type="normalized"), cex.axis=.5,
cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
plot(LDEtraits$Species, resid(aglm_ident, type="normalized"), cex.axis=.5,
cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")
```

```{r, Ant varExp}
# varExp

# aglm_exp <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "ML", weights = varExp(form = ~ LD1), control =  lmeControl(opt= 'nlminb'),  data = LDEtraits)
# 
#AIC(aglm_exp) #AIC = 107.98

```

```{r, Ant varComb}
# varComb

 aglm_comb <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "ML", weights = varComb(varIdent(form = ~ 1|Species), varPower()), control = lmeControl(opt = 'nlminb'),  data = LDEtraits) # Model is not converging as of 02/28/2023
# The model above was not converging because I modeled with a fixed factor (Shannon) that was already reduced with the LDA. It makes it hard converge or there i no convergence at all because of the colinearity it causes (If I remember correctly). -BAR 03/02/2023
# 
# control = lmeControl(msMaxIter = 1000, msMaxEval = 1000)

AIC(aglm_comb) #Lowest AIC yet! 94.85672
summary(aglm_comb)
Anova(aglm_comb, type = "III")
# plot_model(aglm_comb, type = "diag")
#anova(M1,type="marginal") #What is a type III ANOVA?


#Model Validation
op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
plot(LDEtraits$LD1, jitter(resid(aglm_comb, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD1, jitter(resid(aglm_comb, type = "normalized")), xlab = "LD1", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm_comb, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm_comb, type = "normalized")), xlab = "LD2", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_comb, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_comb, type = "normalized")), xlab = "Shannon", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")


#
par(mfrow = c(1,2))
plot(fitted(aglm_comb), resid(aglm_comb, type="normalized"), cex.axis=.5,
cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")

plot(LDEtraits$Species, resid(aglm_comb, type="normalized"), cex.axis=.5,
cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")

```

The model above was not converging because I modeled with a fixed factor (Shannon) that was already reduced with the LDA. It makes it hard converge or there i no convergence at all because of the colinearity it causes (If I remember correctly). -BAR 03/02/2023

```{r, Table comparing Ant linear models}
# Initial model with out variance structure, `varIdent` structure, and `varComb`

tab_model(aglm, aglm_ident, aglm_comb,
          transform = NULL,
          show.est = TRUE,
          show.se = TRUE,
          auto.label = TRUE,
          show.re.var = T, 
          show.aic = TRUE, 
          show.intercept = TRUE, 
          title = "LMM Maximum Likelihood Ant damage",
          # pred.labels = c("Intercept"),
          dv.labels = c("aglm ", "aglm_ident", "aglm_comb"),
          string.pred = "Coefficient",
          string.ci = "CI (95%)",
          string.p = "P-Value",
          digits.p = 3, 
          p.style = c("numeric_stars"))


    # css.depvarhead = 'font-weight:bold;',
    # css.centeralign = 'text-align: left;', 
    # css.firsttablecol = 'font-weight: bold;',
    # css.summary = 'color: black;',
    # p.style = "numeric_stars"))
```

#### Notes on model building with LDA axes

Optimizers: `lmeControl` uses `nlminb` as the default optimizer. Unconstrained and box-constrained optimization using PORT routines. `varIdent` is used to model variance structure because I believe variance varies across tree species (categories).

Variance structure: I explored further, variance modelling with `varComb`. This resulted in the lowest AIC value of all the models. Potentially I can model these interactions with `glmer`. Now, I have to decide if I want to use "generalized" linear mixed effects models or "linear" mixed effects models. I am uncertain of how GLMM's handle variance structure more than just including the random effects.

I tried nesting E_load in Species as a random effect but it increases AIC value (\~100). It is not a big change. Potentially worth including.

Repeat process with pathogen data set.

## Pathogen

### ML-pathogen

```{r, Pathogen Maximum Likelihood model selection}
#nlme package

#Model1
pglm <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species, method = "ML", data = LDEPtraits)
summary(pglm)
anova(pglm)

AIC(pglm) # 182.26
plot_model(pglm, type = "diag")


# Visual Model Validation

pglm_resid <- resid(pglm, type = "response")
pglm_fitted <- fitted(pglm)

plot(pglm_resid)
plot(pglm_fitted)

op <- par(mfrow = c(2, 2), mar = c(4, 4, 2, 2))
plot(LDEPtraits$LD1, jitter(resid(pglm, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$Shannon, jitter(resid(pglm, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")


#Model2
pglm2 <- lme(Pathogen_Damage_area  ~ LD1 + LD2, random = ~1|Species/E_load, method = "ML", data = LDEPtraits)

summary(pglm2)
AIC(pglm2) #184.26
plot_model(pglm2, type = "diag")


#Model3 interactions
pglm3 <- lme(Pathogen_Damage_area ~ LD1 * LD2 , random = ~1|Species/E_load, method = "ML", data = LDEPtraits)

summary(pglm3)
AIC(pglm3) #191.52
plot_model(pglm3, type = "diag")


tab_model(pglm, pglm2, pglm3,
          transform = NULL,
          show.est = TRUE,
          show.se = TRUE,
          auto.label = TRUE,
          show.re.var = T, 
          show.aic = TRUE, 
          show.intercept = TRUE, 
          title = "LMM Maximum Likelihood Pathogen damage",
          # pred.labels = c("Intercept"),
          dv.labels = c("pglm ", "pglm2", "pglm3"),
          string.pred = "Coefficient",
          string.ci = "CI (95%)",
          string.p = "P-Value",
          digits.p = 3, 
          p.style = c("numeric_stars"))
```

### REML-pathogen

```{r, Restricted Maximum Likelihood Models }
preml <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species, method = "REML", data = LDEPtraits) 

summary(preml)
AIC(preml) #192.42
plot_model(preml, type = "diag")

tab_model(pglm, preml, show.re.var = T, show.aic = TRUE, show.intercept = TRUE, title = "LMM Maximum Likelihood Ant damage", CSS = list(
    css.depvarhead = 'font-weight:bold;',
    css.centeralign = 'text-align: left;', 
    css.firsttablecol = 'font-weight: bold;',
    css.summary = 'font-weight: bold;',
    dv.labels = c("pglm ", "preml"),
    p.style = "numeric_stars"))


```

Model estimation with REML increases slightly AIC. Proceeding with ML model estimation.

### Random effects-pathogen

```{r, Checking contribution of random effects-pathogen}

pgls <- gls(Pathogen_Damage_area ~ LD1 + LD2, method = "ML", data = LDEPtraits)

AIC(pglm, pgls)
anova(aglm, agls)
# Species as a random factor decreases AIC value by ~0.5 points.

```

### ML-2-pathogen

Continuation of previous ML section. Moelling variance structure with `varIdent`, `varExp` and `varComb`. The pathogen data set has various nested factors. We have Species with different endophyte load (-+) then each of those individuals had a leaf that served as a control and another that was exposed to the pathogen. Hence, modelling for this data set is slightly different than the Ant data set.

```{r, Pathogen Modelling Variance Structure}
#varIdent
pglm_ident <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species/Treatment, method = "ML", weights = varIdent(form = ~ 1|Species), control =  lmeControl(opt= 'nlminb'),  data = LDEPtraits)

summary(pglm_ident)
AIC(pglm_ident) #132.2
Anova(pglm_ident, type = "III")
plot_model(pglm_ident, type= "diag")

#Modelling variance structure with varIdent returns a lower AIC value (132)


# Model validation
op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
plot(LDEPtraits$LD1, jitter(resid(pglm_ident, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD1, jitter(resid(pglm_ident, type = "normalized")), xlab = "LD1", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm_ident, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm_ident, type = "normalized")), xlab = "LD2", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_ident, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$Shannon, jitter(resid(pglm_ident, type = "normalized")), xlab = "Shannon", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")

#
par(mfrow = c(1,2))
plot(fitted(pglm_ident), resid(pglm_ident, type="normalized"), cex.axis=.5,
cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
plot(LDEPtraits$Species, resid(pglm_ident, type="normalized"), cex.axis=.5,
cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")
```

```{r, Pathogen varExp}
# varExp

pglm_exp <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species/Treatment, method = "ML", weights = varExp(form = ~ LD1|Species), control = lmeControl(msMaxIter = 100, msMaxEval = 100),  data = LDEPtraits)
#control = lmeControl(msMaxIter = 1000, msMaxEval = 1000)
summary(pglm_exp)
AIC(pglm_exp)#162
Anova(pglm_exp, type = "III")
plot_model(pglm_exp, type= "diag")
```

```{r, Pathogen varComb}
# varComb
pglm_comb <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species/Treatment, method = "ML", weights = varComb(varIdent(form = ~ 1 | Species), varPower()), control =  lmeControl(opt = 'nlminb'), data = LDEPtraits) # No convergence -03/03/2023. As of 03/06/2023 the model "reached without convergence". The argument 'returnObject' inside lmeControl is set to TRUE, allowing for this. 

# Optimizer control code. 
#control = lmeControl(msMaxIter = 5000, msMaxEval = 5000, msTol = 1e-7, returnObject = TRUE),
# control =  lmeControl(opt= 'nlminb')

summary(pglm_comb)
Anova(pglm_comb, type = 3)
AIC(pglm_comb) #128.2
plot_model(pglm_comb, type = "diag")

#Model Validation
op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
plot(LDEPtraits$LD1, jitter(resid(pglm_comb, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD1, jitter(resid(pglm_comb, type = "normalized")), xlab = "LD1", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm_comb, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm_comb, type = "normalized")), xlab = "LD2", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$Shannon, jitter(resid(pglm_comb, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$Shannon, jitter(resid(pglm_comb, type = "normalized")), xlab = "Shannon", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")


#
par(mfrow = c(1,2))
plot(fitted(pglm_comb), resid(pglm_comb, type="normalized"), cex.axis=.5,
cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")
plot(LDEPtraits$Species, resid(pglm_comb, type="normalized"), cex.axis=.5,
cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")
```

```{r, Pathogen Table comparing linear models}

# Initial model with out variance structure, "varIdent" structure, and "varComb" structure

tab_model(pglm, pglm_ident, pglm_exp, pglm_comb,
          transform = NULL,
          show.est = TRUE,
          show.se = TRUE,
          auto.label = TRUE,
          show.re.var = T, 
          show.aic = TRUE, 
          show.intercept = TRUE, 
          title = "LMM Maximum Likelihood Pathogen damage",
          # pred.labels = c("Intercept"),
          dv.labels = c("pglm ", "pglm_ident", "pglm_exp", "pglm_comb"),
          string.pred = "Coefficient",
          string.ci = "CI (95%)",
          string.p = "P-Value",
          digits.p = 3, 
          p.style = c("numeric_stars"))


    # css.depvarhead = 'font-weight:bold;',
    # css.centeralign = 'text-align: left;', 
    # css.firsttablecol = 'font-weight: bold;',
    # css.summary = 'color: black;',
    # p.style = "numeric_stars"))
```

# LMM tables and estimate plots for ant and pathogen models with LDA axes

```{r, Tables comparing LMM models}

#This just merges tables made for Ant models and Pathogen models computed in previous sections. 
#
tab_model(aglm_comb, pglm_comb,
          transform = NULL,
          show.est = TRUE,
          show.se = TRUE,
          auto.label = TRUE,
          show.re.var = T,
          show.aic = TRUE,
          show.intercept = TRUE,
          title = "Best-fit LMM's Ant and Pathogen damage",
          pred.labels = c("Intercept", "LD1", "LD2"),
          dv.labels = c("Ant herbivory", "Pathogen damage"),
          string.pred = "Coefficient",
          string.ci = "CI (95%)",
          string.p = "P-Value",
          digits.p = 3,
          p.style = c("numeric_stars"))# file = "H:/.shortcut-targets-by-id/0B9v0CdUUCqU5VVR4a3BvNHM1Z28/VBL_users/Grad_Students/Bolivar/Dissertation/Leaf_Traits_Panama/Data/Sample_Sequencing/Post_Sequencing/Sequence_analyses/Reports/BestFit_LMM_Aant_Pathogen_02152023.html")

```
